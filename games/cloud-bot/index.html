<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cloud Bot - Desvie das Nuvens!</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    font-family: 'Quicksand', sans-serif;
    background: linear-gradient(170deg, #0b0e2b 0%, #1a1e4a 25%, #2d2066 50%, #4a1a6b 70%, #6b1d5e 85%, #1a1040 100%);
    user-select: none;
    cursor: default;
    touch-action: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }

  .stars-layer {
    position: fixed; inset: 0;
    pointer-events: none; z-index: 0;
  }

  .star {
    position: absolute; border-radius: 50%; background: #fff;
    animation: twinkle var(--dur) ease-in-out infinite alternate;
  }

  @keyframes twinkle {
    0% { opacity: 0.15; transform: scale(0.8); }
    100% { opacity: var(--max-op); transform: scale(1.2); }
  }

  .shooting-star {
    position: fixed; width: 240px; height: 6px;
    background: linear-gradient(90deg,
      rgba(255,255,255,0) 0%,
      rgba(255,240,200,0.9) 15%,
      rgba(255,255,255,1) 45%,
      rgba(220,240,255,0.8) 75%,
      rgba(255,255,255,0) 100%);
    border-radius: 3px; opacity: 0; pointer-events: none; z-index: 1;
    filter: blur(2px) drop-shadow(0 0 10px rgba(255,255,150,0.9));
    box-shadow: 0 0 20px 3px rgba(255,220,100,0.7), inset 0 0 5px rgba(255,255,255,0.3);
    transform-origin: center center;
  }

  @keyframes shoot {
    0% { opacity: 0; transform: translateX(-50px) translateY(0) rotate(63.43deg) scale(0.8); }
    8% { opacity: 1; }
    50% { opacity: 0.9; filter: blur(1.5px) drop-shadow(0 0 12px rgba(255,255,200,1)); }
    90% { opacity: 0.4; filter: blur(2px) drop-shadow(0 0 6px rgba(255,200,100,0.4)); }
    100% { opacity: 0; transform: translateX(600px) translateY(300px) rotate(63.43deg) scale(1.2); filter: blur(3px) drop-shadow(0 0 0px transparent); }
  }

  .moon {
    position: fixed; top: 60px; right: 120px;
    width: 80px; height: 80px; border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #ffeedd, #f0c87a);
    box-shadow: 0 0 40px 15px rgba(255,220,150,0.15), 0 0 80px 30px rgba(255,200,100,0.08);
    z-index: 1; pointer-events: none;
  }

  #game-canvas {
    position: fixed; inset: 0;
    z-index: 50; pointer-events: none;
  }

  #cloud-bot {
    position: fixed; z-index: 100;
    pointer-events: none; will-change: transform;
    filter: drop-shadow(0 20px 25px rgba(0,0,0,0.3));
    transition: filter 0.3s ease;
  }

  #cloud-bot.hovered {
    filter: drop-shadow(0 20px 25px rgba(0,0,0,0.3)) drop-shadow(0 0 20px rgba(180,160,255,0.4));
  }

  #cloud-bot.moving .cloud-body { animation: bob-fast 1.2s ease-in-out infinite; }

  .cloud-body { animation: bob 3s ease-in-out infinite; transform-origin: center; }

  @keyframes bob {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
  }
  @keyframes bob-fast {
    0%, 100% { transform: translateY(0) rotate(-2deg); }
    50% { transform: translateY(-10px) rotate(2deg); }
  }

  .blush { opacity: 0.5; transition: opacity 0.5s ease; }
  #cloud-bot.moving .blush { opacity: 0.8; }
  #cloud-bot.sleepy .blush { opacity: 0.3; }
  #cloud-bot.dead .blush { opacity: 0; }

  @keyframes blink {
    0%, 90%, 100% { transform: scaleY(1); }
    95% { transform: scaleY(0.05); }
  }
  .eye-pupil { animation: blink 4s ease-in-out infinite; transform-origin: center; }

  #cloud-bot.sleepy .eye-pupil { animation: sleepy-eyes 3s ease-in-out infinite; }
  @keyframes sleepy-eyes {
    0%, 100% { transform: scaleY(0.3); }
    50% { transform: scaleY(0.15); }
  }

  #cloud-bot.dead .eye-pupil { animation: none; }

  .mouth { transition: all 0.3s ease; }

  .zzz {
    opacity: 0; font-size: 16px; font-weight: 700;
    fill: rgba(180,200,255,0.7); transition: opacity 0.5s ease;
  }
  #cloud-bot.sleepy .zzz { opacity: 1; }
  .zzz-1 { animation: float-z 2s ease-in-out infinite; }
  .zzz-2 { animation: float-z 2s ease-in-out 0.4s infinite; }
  .zzz-3 { animation: float-z 2s ease-in-out 0.8s infinite; }
  @keyframes float-z {
    0% { transform: translate(0,0) scale(0.8); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: translate(15px,-20px) scale(1.1); opacity: 0; }
  }

  .surprise-mark {
    opacity: 0; transition: opacity 0.15s ease;
    font-size: 22px; font-weight: 700; fill: #ffdd57;
  }
  #cloud-bot.surprised .surprise-mark {
    opacity: 1; animation: pop-surprise 0.4s ease-out;
  }
  @keyframes pop-surprise {
    0% { transform: scale(0); }
    50% { transform: scale(1.3) translateY(-5px); }
    100% { transform: scale(1); }
  }

  .sparkle {
    position: fixed; pointer-events: none; z-index: 99;
    border-radius: 50%; animation: sparkle-fade 0.8s ease-out forwards;
  }
  @keyframes sparkle-fade {
    0% { transform: scale(1) translateY(0); opacity: 0.9; }
    100% { transform: scale(0) translateY(20px); opacity: 0; }
  }

  .mini-cloud {
    position: fixed; pointer-events: none; z-index: 98;
    opacity: 0.6; animation: cloud-trail 1s ease-out forwards;
  }
  @keyframes cloud-trail {
    0% { transform: scale(0.8); opacity: 0.5; }
    100% { transform: scale(0.2) translateY(15px); opacity: 0; }
  }

  #ground-shadow {
    position: fixed; bottom: 40px; width: 100px; height: 20px;
    background: radial-gradient(ellipse, rgba(0,0,0,0.25) 0%, transparent 70%);
    border-radius: 50%; z-index: 99; pointer-events: none;
  }

  .hint {
    position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
    color: rgba(180,190,230,0.5); font-size: 14px; letter-spacing: 2px;
    text-transform: uppercase; z-index: 10;
    animation: hint-fade 4s ease-in-out infinite alternate;
    transition: opacity 0.6s ease;
  }
  @keyframes hint-fade {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
  }
  .hint.hidden { opacity: 0 !important; animation: none; }

  @keyframes death-shake {
    0%, 100% { transform: translate(var(--bx), var(--by)); }
    20% { transform: translate(calc(var(--bx) - 8px), calc(var(--by) - 4px)); }
    40% { transform: translate(calc(var(--bx) + 8px), calc(var(--by) + 4px)); }
    60% { transform: translate(calc(var(--bx) - 6px), calc(var(--by) - 2px)); }
    80% { transform: translate(calc(var(--bx) + 4px), calc(var(--by) + 6px)); }
  }
  #cloud-bot.dead {
    filter: drop-shadow(0 0 20px rgba(255,80,80,0.8)) saturate(0.3) brightness(0.7);
    animation: death-shake 0.5s ease-out;
  }

  .back-link, .fullscreen-btn {
    position: fixed; z-index: 200;
    background: rgba(30, 15, 60, 0.7);
    color: rgba(200,190,255,0.8);
    border: 1px solid rgba(200,190,255,0.4);
    padding: 10px 16px;
    border-radius: 6px;
    text-decoration: none;
    font-size: 13px;
    letter-spacing: 0.5px;
    transition: all 0.3s;
    cursor: pointer;
    font-family: 'Quicksand', sans-serif;
  }
  .back-link:hover, .fullscreen-btn:hover {
    color: rgba(255,255,255,0.95);
    border-color: rgba(255,255,255,0.6);
    background: rgba(30, 15, 60, 0.9);
  }
  .back-link { top: 20px; left: 20px; }
  .fullscreen-btn { top: 20px; right: 20px; border: none; }

  body.fullscreen-active .back-link {
    top: 20px; left: 20px;
  }
  body.fullscreen-active .fullscreen-btn {
    top: 20px; right: 20px;
  }
</style>
</head>
<body>

<a href="../../" class="back-link">← MENU</a>
<button id="fullscreen-btn" class="fullscreen-btn">⛶ FULLSCREEN</button>

<div class="stars-layer" id="stars"></div>
<div class="moon"></div>
<canvas id="game-canvas"></canvas>

<div id="cloud-bot">
  <svg width="160" height="140" viewBox="0 0 160 140">
    <g class="cloud-body">
      <ellipse cx="80" cy="78" rx="55" ry="32" fill="url(#cloudGrad)" />
      <ellipse cx="50" cy="70" rx="32" ry="28" fill="url(#cloudGrad)" />
      <ellipse cx="110" cy="70" rx="30" ry="26" fill="url(#cloudGrad)" />
      <ellipse cx="65" cy="55" rx="28" ry="24" fill="url(#cloudGrad)" />
      <ellipse cx="95" cy="52" rx="26" ry="22" fill="url(#cloudGrad)" />
      <ellipse cx="80" cy="48" rx="22" ry="20" fill="url(#cloudGrad)" />
      <ellipse cx="75" cy="68" rx="40" ry="22" fill="url(#innerGlow)" opacity="0.5" />
      <ellipse class="blush" cx="52" cy="80" rx="10" ry="5" fill="rgba(255,150,180,0.35)" />
      <ellipse class="blush" cx="108" cy="80" rx="10" ry="5" fill="rgba(255,150,180,0.35)" />

      <g class="eye" id="left-eye">
        <g class="eye-pupil" id="left-pupil">
          <ellipse cx="65" cy="70" rx="7" ry="8" fill="#2a1f4e" />
          <ellipse cx="63" cy="67" rx="2.5" ry="3" fill="#fff" opacity="0.9" />
          <ellipse cx="67" cy="72" rx="1.5" ry="1.5" fill="#fff" opacity="0.5" />
        </g>
      </g>
      <g class="eye" id="right-eye">
        <g class="eye-pupil" id="right-pupil">
          <ellipse cx="95" cy="70" rx="7" ry="8" fill="#2a1f4e" />
          <ellipse cx="93" cy="67" rx="2.5" ry="3" fill="#fff" opacity="0.9" />
          <ellipse cx="97" cy="72" rx="1.5" ry="1.5" fill="#fff" opacity="0.5" />
        </g>
      </g>

      <g id="dead-eyes" opacity="0">
        <line x1="58" y1="63" x2="72" y2="77" stroke="#2a1f4e" stroke-width="3" stroke-linecap="round"/>
        <line x1="72" y1="63" x2="58" y2="77" stroke="#2a1f4e" stroke-width="3" stroke-linecap="round"/>
        <line x1="88" y1="63" x2="102" y2="77" stroke="#2a1f4e" stroke-width="3" stroke-linecap="round"/>
        <line x1="102" y1="63" x2="88" y2="77" stroke="#2a1f4e" stroke-width="3" stroke-linecap="round"/>
      </g>

      <path class="mouth" id="mouth" d="M 72 85 Q 80 93 88 85" stroke="#2a1f4e" stroke-width="2.5" fill="none" stroke-linecap="round" />
      <ellipse class="mouth" id="mouth-surprised" cx="80" cy="88" rx="5" ry="6" fill="#2a1f4e" opacity="0" />
      <path class="mouth" id="mouth-sleepy" d="M 74 86 Q 80 88 86 86" stroke="#2a1f4e" stroke-width="2" fill="none" stroke-linecap="round" opacity="0" />
      <path id="mouth-dead" d="M 70 88 Q 75 84 80 88 Q 85 92 90 88" stroke="#2a1f4e" stroke-width="2.5" fill="none" stroke-linecap="round" opacity="0"/>

      <text class="zzz zzz-1" x="120" y="45" font-family="Quicksand, sans-serif">z</text>
      <text class="zzz zzz-2" x="130" y="35" font-family="Quicksand, sans-serif" font-size="14">z</text>
      <text class="zzz zzz-3" x="138" y="22" font-family="Quicksand, sans-serif" font-size="12">z</text>
      <text class="surprise-mark" x="115" y="42" font-family="Quicksand, sans-serif">!</text>
    </g>
    <defs>
      <radialGradient id="cloudGrad" cx="40%" cy="30%" r="70%">
        <stop offset="0%" stop-color="#f0eeff" />
        <stop offset="40%" stop-color="#e0daf5" />
        <stop offset="100%" stop-color="#c8bde8" />
      </radialGradient>
      <radialGradient id="innerGlow" cx="50%" cy="40%" r="60%">
        <stop offset="0%" stop-color="#fff" stop-opacity="0.6" />
        <stop offset="100%" stop-color="#fff" stop-opacity="0" />
      </radialGradient>
    </defs>
  </svg>
</div>

<div id="ground-shadow"></div>
<div class="hint" id="hint">passe o mouse por cima da nuvem</div>

<script>
// --- Stars ---
const starsEl = document.getElementById('stars');
for (let i = 0; i < 120; i++) {
  const star = document.createElement('div');
  star.className = 'star';
  const size = Math.random() * 2.5 + 0.5;
  star.style.width = size + 'px';
  star.style.height = size + 'px';
  star.style.left = Math.random() * 100 + '%';
  star.style.top = Math.random() * 100 + '%';
  star.style.setProperty('--dur', (2 + Math.random() * 4) + 's');
  star.style.setProperty('--max-op', (0.4 + Math.random() * 0.6));
  star.style.animationDelay = (Math.random() * 4) + 's';
  starsEl.appendChild(star);
}

function createShootingStar() {
  const el = document.createElement('div');
  el.className = 'shooting-star';
  el.style.top = (Math.random() * 40) + '%';
  el.style.left = (Math.random() * 60) + '%';
  el.style.transform = `rotate(${25 + Math.random() * 20}deg)`;
  el.style.animation = `shoot ${0.8 + Math.random() * 0.4}s ease-out forwards`;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1500);
}
setInterval(createShootingStar, 7000 + Math.random() * 4000);

// --- Canvas setup ---
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

// Mobile detection and hint update
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --- Cloud Bot refs ---
const bot = document.getElementById('cloud-bot');
const shadow = document.getElementById('ground-shadow');
const mouth = document.getElementById('mouth');
const mouthSurprised = document.getElementById('mouth-surprised');
const mouthSleepy = document.getElementById('mouth-sleepy');
const mouthDead = document.getElementById('mouth-dead');
const deadEyes = document.getElementById('dead-eyes');
const hintEl = document.getElementById('hint');

// Update hint for mobile
if (isMobile) {
  hintEl.textContent = 'toque na nuvem';
}

// --- State ---
let mouseX = window.innerWidth / 2;
let mouseY = window.innerHeight / 2;
let botX = window.innerWidth / 2;
let botY = window.innerHeight / 2;
let targetX = botX;
let targetY = botY;
let prevMouseX = mouseX;
let prevMouseY = mouseY;
let velocity = 0;
let idleTime = 0;
let lastMoveTime = Date.now();
let currentExpression = 'happy';
let sparkleTimer = 0;
let prevBotX = botX;
let prevBotY = botY;
let isOverCloud = false;

// --- Game state ---
let gameState = 'waiting';
let score = 0;
let obstacles = [];
let frameCount = 0;
let deathTime = 0;
let spawnTimer = 0;

const OBSTACLE_SPEED_BASE = 1.4;
const OBSTACLE_WIDTH = 150;
const GAP_SIZE = 210;
const SPAWN_INTERVAL_BASE = 210;
const SPAWN_INTERVAL_MIN = 90;
const HIT_RX = 40;
const HIT_RY = 26;
const CLOUD_HIT_RX = 62;
const CLOUD_HIT_RY = 44;

const SPARKLE_COLORS = [
  'rgba(180,160,255,0.8)', 'rgba(255,200,230,0.7)',
  'rgba(200,220,255,0.8)', 'rgba(255,240,180,0.7)', 'rgba(180,255,220,0.6)',
];

function getObstacleSpeed() {
  // Speed scales with both score and time
  const scoreBonus = Math.floor(score / 4) * 0.3; // increased from /5 and *0.2
  const timeBonus = frameCount / 1000; // 1 more speed per 1000 frames
  return OBSTACLE_SPEED_BASE + scoreBonus + timeBonus;
}

function getSpawnInterval() {
  // Spawn rate increases as game progresses (more obstacles come faster)
  const scoreReduction = Math.floor(score / 6) * 4; // every 6 points reduces by 4 frames
  const timeReduction = Math.floor(frameCount / 500) * 2; // every 500 frames reduces by 2
  const interval = SPAWN_INTERVAL_BASE - scoreReduction - timeReduction;
  return Math.max(SPAWN_INTERVAL_MIN, interval);
}

function isMouseOverCloud(mx, my) {
  const dx = (mx - botX) / CLOUD_HIT_RX;
  const dy = (my - (botY - 8)) / CLOUD_HIT_RY;
  return (dx * dx + dy * dy) <= 1;
}

function handlePositionChange(x, y) {
  prevMouseX = mouseX;
  prevMouseY = mouseY;
  mouseX = x;
  mouseY = y;

  const wasOverCloud = isOverCloud;
  isOverCloud = isMouseOverCloud(mouseX, mouseY);

  // Always follow the mouse
  targetX = mouseX;
  targetY = mouseY;

  if (gameState !== 'dead') {
    lastMoveTime = Date.now();
    idleTime = 0;

    if (gameState === 'waiting') {
      gameState = 'playing';
      hintEl.classList.add('hidden');
    }
  }

  // Allow restart by moving over cloud after death
  if (isOverCloud && gameState === 'dead' && Date.now() - deathTime > 1500) {
    restartGame();
  }

  if (isOverCloud !== wasOverCloud) {
    bot.classList.toggle('hovered', isOverCloud && gameState !== 'dead');
    document.body.style.cursor = isOverCloud ? 'none' : 'default';
  }
}

document.addEventListener('mousemove', (e) => {
  handlePositionChange(e.clientX, e.clientY);
});

document.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length > 0) {
    const touch = e.touches[0];
    handlePositionChange(touch.clientX, touch.clientY);
  }
}, { passive: false });

document.addEventListener('touchstart', (e) => {
  if (e.touches.length > 0) {
    const touch = e.touches[0];
    handlePositionChange(touch.clientX, touch.clientY);
  }
});

function setExpression(expr) {
  currentExpression = expr;
  bot.classList.remove('moving', 'sleepy', 'surprised', 'dead');

  mouth.style.opacity = '0';
  mouthSurprised.style.opacity = '0';
  mouthSleepy.style.opacity = '0';
  mouthDead.style.opacity = '0';
  deadEyes.style.opacity = '0';
  document.getElementById('left-eye').style.opacity = '1';
  document.getElementById('right-eye').style.opacity = '1';

  switch (expr) {
    case 'happy':
      mouth.setAttribute('d', 'M 72 85 Q 80 93 88 85');
      mouth.style.opacity = '1';
      break;
    case 'excited':
      bot.classList.add('moving');
      mouth.setAttribute('d', 'M 70 84 Q 80 96 90 84');
      mouth.style.opacity = '1';
      break;
    case 'sleepy':
      bot.classList.add('sleepy');
      mouthSleepy.style.opacity = '1';
      break;
    case 'surprised':
      bot.classList.add('surprised');
      mouthSurprised.style.opacity = '1';
      break;
    case 'dead':
      bot.classList.add('dead');
      mouthDead.style.opacity = '1';
      deadEyes.style.opacity = '1';
      document.getElementById('left-eye').style.opacity = '0';
      document.getElementById('right-eye').style.opacity = '0';
      break;
  }
}

function createSparkle(x, y) {
  const el = document.createElement('div');
  el.className = 'sparkle';
  const color = SPARKLE_COLORS[Math.floor(Math.random() * SPARKLE_COLORS.length)];
  el.style.background = color;
  el.style.boxShadow = `0 0 6px ${color}`;
  el.style.left = (x + (Math.random() - 0.5) * 40) + 'px';
  el.style.top = (y + (Math.random() - 0.5) * 20 + 20) + 'px';
  const size = 3 + Math.random() * 6;
  el.style.width = size + 'px';
  el.style.height = size + 'px';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

function createMiniCloud(x, y) {
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '30');
  svg.setAttribute('height', '20');
  svg.setAttribute('viewBox', '0 0 30 20');
  svg.classList.add('mini-cloud');
  svg.style.left = (x + (Math.random() - 0.5) * 30) + 'px';
  svg.style.top = (y + 15 + Math.random() * 10) + 'px';
  const e1 = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
  e1.setAttribute('cx','15'); e1.setAttribute('cy','12');
  e1.setAttribute('rx','12'); e1.setAttribute('ry','7');
  e1.setAttribute('fill','rgba(200,190,240,0.4)');
  const e2 = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
  e2.setAttribute('cx','10'); e2.setAttribute('cy','10');
  e2.setAttribute('rx','8'); e2.setAttribute('ry','6');
  e2.setAttribute('fill','rgba(200,190,240,0.3)');
  svg.appendChild(e1); svg.appendChild(e2);
  document.body.appendChild(svg);
  setTimeout(() => svg.remove(), 1000);
}

function spawnObstacle() {
  // Reduce margin as difficulty increases for more height variation
  const basemargin = 60;
  const difficultyMarginReduction = Math.min(40, Math.floor(score / 10) * 5);
  const margin = Math.max(30, basemargin - difficultyMarginReduction);

  const minGapY = GAP_SIZE / 2 + margin;
  const maxGapY = window.innerHeight - GAP_SIZE / 2 - margin;

  obstacles.push({
    x: window.innerWidth + OBSTACLE_WIDTH / 2 + 30,
    gapCenterY: minGapY + Math.random() * (maxGapY - minGapY),
    passed: false,
    lightningTimer: Math.random() * 60,
  });
}

function checkCollision(obs) {
  if (Math.abs(botX - obs.x) > (OBSTACLE_WIDTH / 2 + HIT_RX - 10)) return false;
  const gapTop = obs.gapCenterY - GAP_SIZE / 2;
  const gapBottom = obs.gapCenterY + GAP_SIZE / 2;
  return (botY - HIT_RY < gapTop) || (botY + HIT_RY > gapBottom);
}

function killPlayer() {
  gameState = 'dead';
  deathTime = Date.now();
  setExpression('dead');
  isOverCloud = false;
  bot.classList.remove('hovered');
  document.body.style.cursor = 'default';
}

function restartGame() {
  obstacles = [];
  score = 0;
  frameCount = 0;
  spawnTimer = 0;
  gameState = 'playing';
  setExpression('happy');
  hintEl.classList.add('hidden');
}

function drawCloudPuff(x, y, rx, ry, dark) {
  const grad = ctx.createRadialGradient(x - rx*0.2, y - ry*0.2, 0, x, y, Math.max(rx, ry));
  if (dark) {
    grad.addColorStop(0, 'rgba(45, 28, 70, 0.97)');
    grad.addColorStop(0.5, 'rgba(22, 12, 48, 0.98)');
    grad.addColorStop(1, 'rgba(8, 4, 22, 0.99)');
  } else {
    grad.addColorStop(0, 'rgba(60, 35, 85, 0.95)');
    grad.addColorStop(1, 'rgba(15, 8, 35, 0.98)');
  }
  ctx.beginPath();
  ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
  ctx.fillStyle = grad;
  ctx.fill();
}

function drawAngryFace(x, y, flipped) {
  const eyeY = y + (flipped ? 6 : -6);
  const browY = y + (flipped ? -2 : 2);

  [-16, 16].forEach((ox) => {
    const glowGrad = ctx.createRadialGradient(x + ox, eyeY, 0, x + ox, eyeY, 9);
    glowGrad.addColorStop(0, 'rgba(255, 100, 80, 1)');
    glowGrad.addColorStop(0.5, 'rgba(200, 40, 40, 0.8)');
    glowGrad.addColorStop(1, 'rgba(150, 20, 20, 0)');
    ctx.beginPath();
    ctx.arc(x + ox, eyeY, 9, 0, Math.PI * 2);
    ctx.fillStyle = glowGrad;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + ox, eyeY, 3.5, 0, Math.PI * 2);
    ctx.fillStyle = '#0a0010';
    ctx.fill();
  });

  ctx.strokeStyle = 'rgba(255, 70, 60, 0.9)';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x - 24, browY + (flipped ? 5 : -5));
  ctx.lineTo(x - 8, browY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + 8, browY);
  ctx.lineTo(x + 24, browY + (flipped ? 5 : -5));
  ctx.stroke();
}

function drawLightningBolt(x, y, scale) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);
  ctx.strokeStyle = 'rgba(255, 230, 60, 0.85)';
  ctx.fillStyle = 'rgba(255, 230, 60, 0.7)';
  ctx.lineWidth = 1.5;
  ctx.shadowColor = 'rgba(255, 220, 50, 0.8)';
  ctx.shadowBlur = 8;
  ctx.beginPath();
  ctx.moveTo(4, -12);
  ctx.lineTo(-2, 0);
  ctx.lineTo(2, 0);
  ctx.lineTo(-4, 12);
  ctx.lineTo(6, 1);
  ctx.lineTo(2, 1);
  ctx.lineTo(8, -12);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawObstacle(obs) {
  const x = obs.x;
  const gapTop = obs.gapCenterY - GAP_SIZE / 2;
  const gapBottom = obs.gapCenterY + GAP_SIZE / 2;
  const hw = OBSTACLE_WIDTH / 2;

  if (gapTop > 0) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(x - hw - 15, -10, OBSTACLE_WIDTH + 30, gapTop + 10);
    ctx.clip();

    const topGrad = ctx.createLinearGradient(x - hw, 0, x + hw, gapTop);
    topGrad.addColorStop(0, 'rgba(12, 6, 30, 0.96)');
    topGrad.addColorStop(1, 'rgba(30, 15, 55, 0.97)');
    ctx.fillStyle = topGrad;
    ctx.fillRect(x - hw - 15, -10, OBSTACLE_WIDTH + 30, gapTop + 10);

    const puffR = 30;
    const n = Math.ceil(OBSTACLE_WIDTH / (puffR * 1.5)) + 1;
    for (let i = 0; i < n; i++) {
      const px = x - hw + i * (OBSTACLE_WIDTH / (n - 1));
      drawCloudPuff(px, gapTop + 2, puffR + 4, puffR - 4, i % 2 === 0);
    }
    for (let i = 0; i < n - 1; i++) {
      const px = x - hw + (i + 0.5) * (OBSTACLE_WIDTH / (n - 1));
      drawCloudPuff(px, gapTop - puffR * 0.7, puffR * 0.85, puffR * 0.7, true);
    }

    const rimGrad = ctx.createLinearGradient(0, gapTop - 25, 0, gapTop);
    rimGrad.addColorStop(0, 'rgba(180,40,40,0)');
    rimGrad.addColorStop(1, 'rgba(220,60,50,0.35)');
    ctx.fillStyle = rimGrad;
    ctx.fillRect(x - hw, gapTop - 25, OBSTACLE_WIDTH, 25);

    ctx.restore();

    if (gapTop > 70) {
      drawAngryFace(x, gapTop - 42, false);
    }
  }

  if (gapBottom < canvas.height) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(x - hw - 15, gapBottom, OBSTACLE_WIDTH + 30, canvas.height - gapBottom + 10);
    ctx.clip();

    const botGrad = ctx.createLinearGradient(x - hw, gapBottom, x + hw, canvas.height);
    botGrad.addColorStop(0, 'rgba(30, 15, 55, 0.97)');
    botGrad.addColorStop(1, 'rgba(12, 6, 30, 0.96)');
    ctx.fillStyle = botGrad;
    ctx.fillRect(x - hw - 15, gapBottom, OBSTACLE_WIDTH + 30, canvas.height - gapBottom + 10);

    const puffR = 30;
    const n = Math.ceil(OBSTACLE_WIDTH / (puffR * 1.5)) + 1;
    for (let i = 0; i < n; i++) {
      const px = x - hw + i * (OBSTACLE_WIDTH / (n - 1));
      drawCloudPuff(px, gapBottom - 2, puffR + 4, puffR - 4, i % 2 === 0);
    }
    for (let i = 0; i < n - 1; i++) {
      const px = x - hw + (i + 0.5) * (OBSTACLE_WIDTH / (n - 1));
      drawCloudPuff(px, gapBottom + puffR * 0.7, puffR * 0.85, puffR * 0.7, true);
    }

    const rimGrad2 = ctx.createLinearGradient(0, gapBottom, 0, gapBottom + 25);
    rimGrad2.addColorStop(0, 'rgba(220,60,50,0.35)');
    rimGrad2.addColorStop(1, 'rgba(180,40,40,0)');
    ctx.fillStyle = rimGrad2;
    ctx.fillRect(x - hw, gapBottom, OBSTACLE_WIDTH, 25);

    ctx.restore();

    if (canvas.height - gapBottom > 70) {
      drawAngryFace(x, gapBottom + 42, true);
    }
  }

  obs.lightningTimer += 1;
  if (Math.floor(obs.lightningTimer) % 90 < 8) {
    const lx = x + (Math.random() - 0.5) * 30;
    drawLightningBolt(lx, gapTop - 15, 1.2);
    drawLightningBolt(lx + 20, gapBottom + 10, 1.0);
  }
}

function drawScore() {
  ctx.save();
  ctx.font = 'bold 52px Quicksand, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.shadowColor = 'rgba(120,90,220,0.9)';
  ctx.shadowBlur = 25;
  ctx.fillText(score, canvas.width / 2, 75);
  ctx.restore();
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(8, 4, 20, 0.78)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  ctx.save();
  const panelW = 400, panelH = 200;
  const panelX = cx - panelW / 2;
  const panelY = cy - panelH / 2 - 10;
  const panelGrad = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelH);
  panelGrad.addColorStop(0, 'rgba(30, 15, 60, 0.9)');
  panelGrad.addColorStop(1, 'rgba(15, 8, 35, 0.95)');
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 20);
  ctx.fillStyle = panelGrad;
  ctx.fill();
  ctx.strokeStyle = 'rgba(180, 60, 80, 0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();

  ctx.save();
  ctx.textAlign = 'center';

  ctx.font = 'bold 52px Quicksand, sans-serif';
  ctx.fillStyle = '#ff4466';
  ctx.shadowColor = 'rgba(255,50,80,0.7)';
  ctx.shadowBlur = 25;
  ctx.fillText('FIM DE JOGO', cx, cy - 18);

  ctx.font = '600 26px Quicksand, sans-serif';
  ctx.fillStyle = 'rgba(210,195,255,0.95)';
  ctx.shadowBlur = 8;
  ctx.fillText(`Pontuação: ${score}`, cx, cy + 25);

  if (Date.now() - deathTime > 1500) {
    ctx.font = '16px Quicksand, sans-serif';
    ctx.fillStyle = 'rgba(160, 150, 210, 0.7)';
    ctx.shadowBlur = 0;
    ctx.fillText('passe o mouse pela nuvem para recomeçar', cx, cy + 70);
  }

  ctx.restore();
}

function animate() {
  const now = Date.now();
  idleTime = now - lastMoveTime;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (gameState === 'playing') {
    frameCount++;
    spawnTimer++;

    if (spawnTimer >= getSpawnInterval()) {
      spawnTimer = 0;
      spawnObstacle();
    }

    const speed = getObstacleSpeed();

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs = obstacles[i];
      obs.x -= speed;

      if (!obs.passed && obs.x < botX - OBSTACLE_WIDTH / 2) {
        obs.passed = true;
        score++;
      }

      if (obs.x < -OBSTACLE_WIDTH) {
        obstacles.splice(i, 1);
        continue;
      }

      if (checkCollision(obs)) {
        killPlayer();
        break;
      }

      drawObstacle(obs);
    }

    drawScore();
  } else if (gameState === 'dead') {
    obstacles.forEach(drawObstacle);
    drawGameOver();
  }

  const ease = 0.15; // Smooth following like Claudinho Dodge
  const dx = targetX - botX;
  const dy = targetY - botY;
  botX += dx * ease;
  botY += dy * ease;

  const bvx = botX - prevBotX;
  const bvy = botY - prevBotY;
  velocity = Math.sqrt(bvx * bvx + bvy * bvy);
  prevBotX = botX;
  prevBotY = botY;

  bot.style.transform = `translate(${botX - 80}px, ${botY - 70}px)`;

  shadow.style.left = (botX - 50) + 'px';
  const distFromBottom = window.innerHeight - botY;
  const shadowScale = Math.max(0.3, Math.min(1, distFromBottom / 300));
  shadow.style.transform = `scaleX(${shadowScale})`;
  shadow.style.opacity = shadowScale * 0.5;

  if (gameState !== 'dead') {
    if (velocity > 3 && currentExpression !== 'surprised') {
      if (currentExpression !== 'excited') setExpression('excited');
    } else if (idleTime > 4000 && gameState === 'waiting' && currentExpression !== 'surprised') {
      if (currentExpression !== 'sleepy') setExpression('sleepy');
    } else if (velocity < 1 && idleTime < 4000 && currentExpression !== 'surprised') {
      if (currentExpression !== 'happy') setExpression('happy');
    }
  }

  sparkleTimer++;
  if (velocity > 2 && sparkleTimer % 3 === 0) createSparkle(botX, botY);
  if (velocity > 5 && sparkleTimer % 8 === 0) createMiniCloud(botX, botY);

  const eyeDx = mouseX - botX;
  const eyeDy = mouseY - botY;
  if (gameState !== 'dead') {
    const eyeOffsetX = Math.min(3, Math.max(-3, eyeDx * 0.025));
    const eyeOffsetY = Math.min(2, Math.max(-2, eyeDy * 0.025));
    document.getElementById('left-eye').style.transform = `translate(${eyeOffsetX}px, ${eyeOffsetY}px)`;
    document.getElementById('right-eye').style.transform = `translate(${eyeOffsetX}px, ${eyeOffsetY}px)`;
  }

  requestAnimationFrame(animate);
}

setExpression('happy');
animate();
setTimeout(createShootingStar, 2000);

// --- Fullscreen functionality ---
const fullscreenBtn = document.getElementById('fullscreen-btn');
const backBtn = document.querySelector('.back-link');

fullscreenBtn.addEventListener('click', () => {
  const elem = document.documentElement;
  if (!document.fullscreenElement) {
    if (elem.requestFullscreen) {
      elem.requestFullscreen().catch(err => console.log('Fullscreen error:', err));
      document.body.classList.add('fullscreen-active');
      fullscreenBtn.textContent = '⛶ SAIR FS';
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
      document.body.classList.remove('fullscreen-active');
      fullscreenBtn.textContent = '⛶ FULLSCREEN';
    }
  }
});

document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement) {
    document.body.classList.remove('fullscreen-active');
    fullscreenBtn.textContent = '⛶ FULLSCREEN';
  }
});

// Prevent going to menu during game
backBtn.addEventListener('click', (e) => {
  if (gameState === 'playing') {
    e.preventDefault();
    const confirmed = confirm('Tem certeza? Seu progresso será perdido.');
    if (confirmed) {
      window.location.href = '../../';
    }
  }
});
</script>

</body>
</html>
