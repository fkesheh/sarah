<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Lunar Base - Defenda sua Base!</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    background: #0a0a12;
    font-family: 'Share Tech Mono', monospace;
    user-select: none;
    cursor: crosshair;
    touch-action: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    overscroll-behavior: none;
  }

  html { overscroll-behavior: none; }

  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
  }

  /* ─── CRT Scanline Overlay ─── */
  .crt-overlay {
    position: fixed; inset: 0;
    pointer-events: none; z-index: 200;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.08) 2px,
      rgba(0,0,0,0.08) 4px
    );
  }

  .crt-overlay::after {
    content: '';
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
    pointer-events: none;
  }

  /* ─── HUD ─── */
  .hud {
    position: fixed; top: 0; left: 0; right: 0;
    z-index: 100; pointer-events: none;
    padding: 16px 24px;
    padding-left: 100px;
    display: flex; justify-content: space-between; align-items: flex-start;
  }

  .hud-left, .hud-right, .hud-center {
    display: flex; flex-direction: column; gap: 6px;
  }

  .hud-center {
    align-items: center;
    position: absolute; left: 50%; transform: translateX(-50%);
  }

  .hud-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: rgba(0,255,136,0.5);
    text-transform: uppercase;
    letter-spacing: 3px;
  }

  .hud-value {
    font-family: 'Orbitron', monospace;
    font-size: 24px;
    color: #00ff88;
    text-shadow: 0 0 10px rgba(0,255,136,0.6), 0 0 30px rgba(0,255,136,0.2);
  }

  .hud-value.score-value { font-size: 32px; }

  .hud-bar-container {
    width: 120px; height: 8px;
    background: rgba(0,255,136,0.1);
    border: 1px solid rgba(0,255,136,0.3);
    border-radius: 2px;
    overflow: hidden;
  }

  .hud-bar {
    height: 100%;
    transition: width 0.3s ease;
    border-radius: 1px;
  }

  .health-bar { background: linear-gradient(90deg, #ff2244, #ff6644); box-shadow: 0 0 8px rgba(255,34,68,0.5); }
  .ammo-bar { background: linear-gradient(90deg, #00ff88, #00ccff); box-shadow: 0 0 8px rgba(0,255,136,0.5); }

  .hud-right { align-items: flex-end; }

  .wave-display {
    font-family: 'Orbitron', monospace;
    font-size: 14px;
    color: #ff8800;
    text-shadow: 0 0 8px rgba(255,136,0,0.5);
  }

  .combo-display {
    font-family: 'Orbitron', monospace;
    font-size: 14px;
    color: #ffcc00;
    text-shadow: 0 0 8px rgba(255,204,0,0.5);
    opacity: 0;
    transition: opacity 0.3s;
  }

  .combo-display.visible { opacity: 1; }

  /* ─── Screens ─── */
  .screen-overlay {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 150;
    transition: opacity 0.6s;
  }

  .screen-overlay.hidden {
    opacity: 0; pointer-events: none;
  }

  .title-text {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: clamp(36px, 10vw, 80px);
    color: #00ff88;
    text-shadow:
      0 0 20px rgba(0,255,136,0.8),
      0 0 60px rgba(0,255,136,0.4),
      0 0 100px rgba(0,255,136,0.2),
      4px 4px 0 rgba(0,0,0,0.8);
    letter-spacing: 6px;
    animation: titlePulse 3s ease-in-out infinite;
    text-align: center;
  }

  .subtitle-text {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(12px, 3vw, 18px);
    color: rgba(255,136,0,0.9);
    text-shadow: 0 0 10px rgba(255,136,0,0.5);
    letter-spacing: 8px;
    text-transform: uppercase;
    margin-top: 16px;
    animation: subtitleFlicker 4s ease-in-out infinite;
  }

  .instruction-text {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(14px, 2.5vw, 20px);
    color: rgba(0,255,136,0.7);
    margin-top: 48px;
    letter-spacing: 2px;
    animation: blink 2.5s ease-in-out infinite;
  }

  .game-over-score {
    font-family: 'Orbitron', monospace;
    font-size: clamp(20px, 5vw, 36px);
    color: #00ff88;
    text-shadow: 0 0 15px rgba(0,255,136,0.6);
    margin-top: 24px;
  }

  .game-over-detail {
    font-family: 'Share Tech Mono', monospace;
    font-size: 16px;
    color: rgba(0,255,136,0.6);
    margin-top: 8px;
  }

  .restart-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 18px;
    color: #0a0a12;
    background: #00ff88;
    border: none;
    padding: 14px 40px;
    margin-top: 32px;
    cursor: pointer;
    letter-spacing: 3px;
    text-transform: uppercase;
    box-shadow: 0 0 20px rgba(0,255,136,0.4), 0 0 60px rgba(0,255,136,0.1);
    transition: all 0.2s;
  }

  .restart-btn:hover {
    background: #44ffaa;
    box-shadow: 0 0 30px rgba(0,255,136,0.6), 0 0 80px rgba(0,255,136,0.2);
    transform: scale(1.05);
  }

  .restart-btn:active { transform: scale(0.97); }

  .back-link {
    position: fixed; top: 12px; left: 12px; z-index: 300;
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px; color: rgba(0,255,136,0.5);
    text-decoration: none;
    padding: 6px 14px;
    border: 1px solid rgba(0,255,136,0.2);
    border-radius: 4px;
    transition: all 0.2s;
    background: rgba(10,10,18,0.7);
  }

  .back-link:hover {
    color: #00ff88;
    border-color: rgba(0,255,136,0.5);
    background: rgba(10,10,18,0.9);
  }

  @keyframes titlePulse {
    0%, 100% { text-shadow: 0 0 20px rgba(0,255,136,0.8), 0 0 60px rgba(0,255,136,0.4), 0 0 100px rgba(0,255,136,0.2), 4px 4px 0 rgba(0,0,0,0.8); }
    50% { text-shadow: 0 0 30px rgba(0,255,136,1), 0 0 80px rgba(0,255,136,0.6), 0 0 120px rgba(0,255,136,0.3), 4px 4px 0 rgba(0,0,0,0.8); }
  }

  @keyframes subtitleFlicker {
    0%, 100% { opacity: 0.9; }
    50% { opacity: 0.75; }
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  @media (max-width: 640px) {
    .hud { padding: 10px 14px; }
    .hud-value { font-size: 18px; }
    .hud-value.score-value { font-size: 22px; }
    .hud-bar-container { width: 80px; height: 6px; }
    .hud-label { font-size: 8px; letter-spacing: 2px; }
    .wave-display { font-size: 12px; }
  }
</style>
</head>
<body>

<a href="../../" class="back-link">← MENU</a>

<canvas id="game-canvas"></canvas>
<div class="crt-overlay"></div>

<!-- HUD -->
<div class="hud" id="hud" style="opacity: 0;">
  <div class="hud-left">
    <div class="hud-label">Pontuação</div>
    <div class="hud-value score-value" id="score-hud">0</div>
    <div class="hud-label" style="margin-top: 8px;">Recorde</div>
    <div class="hud-value" id="highscore-hud" style="font-size: 14px; opacity: 0.6;">0</div>
  </div>
  <div class="hud-center">
    <div class="wave-display" id="wave-hud">ONDA 1</div>
    <div class="combo-display" id="combo-hud">COMBO x2</div>
  </div>
  <div class="hud-right">
    <div class="hud-label">Base</div>
    <div class="hud-bar-container">
      <div class="hud-bar health-bar" id="health-bar" style="width: 100%;"></div>
    </div>
    <div class="hud-label" style="margin-top: 8px;">Energia</div>
    <div class="hud-bar-container">
      <div class="hud-bar ammo-bar" id="ammo-bar" style="width: 100%;"></div>
    </div>
  </div>
</div>

<!-- Start Screen -->
<div class="screen-overlay" id="start-screen">
  <div class="title-text">LUNAR<br>BASE</div>
  <div class="subtitle-text">Defenda sua base</div>
  <div class="instruction-text">[ CLIQUE PARA ATIRAR ]</div>
</div>

<!-- Game Over Screen -->
<div class="screen-overlay hidden" id="gameover-screen">
  <div class="title-text" style="font-size: clamp(28px, 7vw, 56px); color: #ff2244; text-shadow: 0 0 20px rgba(255,34,68,0.8), 0 0 60px rgba(255,34,68,0.4), 4px 4px 0 rgba(0,0,0,0.8);">
    GAME OVER
  </div>
  <div class="game-over-score" id="final-score">0</div>
  <div class="game-over-detail" id="final-wave">Ondas Sobrevividas: 0</div>
  <div class="game-over-detail" id="final-record"></div>
  <button class="restart-btn" id="restart-btn">JOGAR NOVAMENTE</button>
</div>

<!-- Wave Announcement -->
<div class="screen-overlay hidden" id="wave-announce" style="pointer-events: none;">
  <div class="wave-display" style="font-size: clamp(28px, 8vw, 56px); letter-spacing: 6px;" id="wave-announce-text">ONDA 1</div>
</div>

<script>
// ─── CANVAS SETUP ───
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ─── GAME CONFIG ───
const CFG = {
  baseHealth: 3,
  maxAmmo: 8,
  ammoRegenRate: 3,
  laserSpeed: 14,
  laserCooldown: 250,
  blastRadius: 55,
  meteorSizes: {
    small:  { r: 10, speed: 2.8, points: 10, color: '#ff6644' },
    medium: { r: 20, speed: 1.8, points: 25, color: '#ff8844' },
    large:  { r: 32, speed: 1.2, points: 50, color: '#ffaa44' },
    boss:   { r: 52, speed: 0.8, points: 200, color: '#ff2244', hp: 3 },
  },
  waveBaseMeteors: 5,
  waveMeteorIncrease: 2,
  waveSpeedMultiplier: 0.06,
  bossWaveInterval: 5,
  splitWaveThreshold: 10,
  groundY: 0.88,
  turretY: 0.84,
  comboTimeLimit: 2000,
};

// ─── GAME STATE ───
let gameState = 'start';
let score = 0;
let highScore = parseInt(localStorage.getItem('lunarBaseHighScore')) || 0;
let wave = 1;
let baseHealth = CFG.baseHealth;
let ammo = CFG.maxAmmo;
let lastShotTime = 0;
let combo = 0;
let lastComboTime = 0;
let shakeTime = 0;
let shakeIntensity = 0;
let flashAlpha = 0;

let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;
let turretAngle = -Math.PI / 2;

let meteors = [];
let lasers = [];
let explosions = [];
let particles = [];
let floatingTexts = [];
let stars = [];

let waveMetorsRemaining = 0;
let waveSpawnTimer = 0;
let waveSpawnInterval = 2000;
let waveActive = false;
let wavePaused = false;
let waveAnnounceTimer = 0;

// ─── STARS BACKGROUND ───
function initStars() {
  stars = [];
  for (let i = 0; i < 200; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * CFG.groundY,
      size: Math.random() * 2 + 0.5,
      twinkleSpeed: Math.random() * 0.002 + 0.0005,
      twinkleOffset: Math.random() * Math.PI * 2,
      brightness: Math.random() * 0.5 + 0.3,
    });
  }
}
initStars();

// ─── DRAWING HELPERS ───
function getGroundY() { return canvas.height * CFG.groundY; }
function getTurretX() { return canvas.width / 2; }
function getTurretY() { return getGroundY() - 50; }

function drawStars(time) {
  for (const s of stars) {
    const alpha = s.brightness + Math.sin(time * s.twinkleSpeed + s.twinkleOffset) * 0.3;
    ctx.fillStyle = `rgba(200,220,255,${Math.max(0.05, alpha)})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawLunarSurface() {
  const gy = getGroundY();
  const w = canvas.width;
  const h = canvas.height;

  // Main surface
  ctx.fillStyle = '#1a1a2a';
  ctx.fillRect(0, gy, w, h - gy);

  // Surface line with glow
  ctx.strokeStyle = 'rgba(0,255,136,0.3)';
  ctx.lineWidth = 2;
  ctx.shadowColor = 'rgba(0,255,136,0.3)';
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.moveTo(0, gy);

  // Uneven terrain
  for (let x = 0; x <= w; x += 40) {
    const yOff = Math.sin(x * 0.008) * 4 + Math.sin(x * 0.02) * 2;
    ctx.lineTo(x, gy + yOff);
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Craters
  const craters = [
    { x: w * 0.15, y: gy + 30, r: 25 },
    { x: w * 0.35, y: gy + 45, r: 18 },
    { x: w * 0.65, y: gy + 35, r: 22 },
    { x: w * 0.82, y: gy + 50, r: 15 },
    { x: w * 0.92, y: gy + 25, r: 12 },
  ];

  for (const c of craters) {
    ctx.fillStyle = 'rgba(10,10,20,0.6)';
    ctx.beginPath();
    ctx.ellipse(c.x, c.y, c.r, c.r * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(0,255,136,0.08)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.ellipse(c.x, c.y, c.r, c.r * 0.4, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function drawBase() {
  const tx = getTurretX();
  const gy = getGroundY();
  const damage = 1 - baseHealth / CFG.baseHealth;

  // Base dome
  const domeW = 130;
  const domeH = 50;

  ctx.save();

  // Dome glow
  const domeGrad = ctx.createRadialGradient(tx, gy - 5, 10, tx, gy - 5, domeW);
  domeGrad.addColorStop(0, 'rgba(0,255,136,0.08)');
  domeGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = domeGrad;
  ctx.fillRect(tx - domeW, gy - domeH - 20, domeW * 2, domeH + 25);

  // Dome body
  ctx.fillStyle = `rgba(20,30,40,0.95)`;
  ctx.beginPath();
  ctx.ellipse(tx, gy, domeW, domeH, 0, Math.PI, 0);
  ctx.fill();

  // Dome outline
  const outlineColor = damage > 0.66 ? '#ff2244' : damage > 0.33 ? '#ff8800' : '#00ff88';
  ctx.strokeStyle = outlineColor;
  ctx.lineWidth = 2;
  ctx.shadowColor = outlineColor;
  ctx.shadowBlur = 12;
  ctx.beginPath();
  ctx.ellipse(tx, gy, domeW, domeH, 0, Math.PI, 0);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Dome damage cracks
  if (damage > 0) {
    ctx.strokeStyle = `rgba(255,34,68,${damage * 0.6})`;
    ctx.lineWidth = 1;
    for (let i = 0; i < Math.floor(damage * 6); i++) {
      const cx = tx + (Math.random() - 0.5) * domeW * 1.5;
      const cy = gy - Math.random() * domeH * 0.8;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + (Math.random() - 0.5) * 20, cy + Math.random() * 15);
      ctx.lineTo(cx + (Math.random() - 0.5) * 15, cy + Math.random() * 20);
      ctx.stroke();
    }
  }

  // Window lights on dome
  const windowColors = ['rgba(0,255,136,0.4)', 'rgba(0,200,255,0.3)', 'rgba(255,200,0,0.3)'];
  for (let i = -3; i <= 3; i++) {
    const wx = tx + i * 30;
    const ratio = Math.abs(i * 30 / domeW);
    if (ratio >= 1) continue;
    const angle = Math.acos(ratio);
    const wy = gy - Math.sin(angle) * domeH * 0.6;
    if (damage < 0.66 || Math.random() > 0.3) {
      ctx.fillStyle = windowColors[Math.abs(i) % windowColors.length];
      ctx.fillRect(wx - 5, wy - 4, 10, 8);
    }
  }

  ctx.restore();
}

// 5 cannons along the dome arc — each with independent stats
// Index 0,4 = outermost (fast, weak), index 2 = center (slow, strong)
const cannonDefs = [
  { offset: -80, cooldown: 150, damage: 1, bulletSize: 1.8, regenRate: 2.8, maxAmmo: 6 },
  { offset: -40, cooldown: 200, damage: 1, bulletSize: 2.2, regenRate: 2.45, maxAmmo: 5 },
  { offset:   0, cooldown: 350, damage: 3, bulletSize: 4.0, regenRate: 1.4, maxAmmo: 4 },
  { offset:  40, cooldown: 200, damage: 1, bulletSize: 2.2, regenRate: 2.45, maxAmmo: 5 },
  { offset:  80, cooldown: 150, damage: 1, bulletSize: 1.8, regenRate: 2.8, maxAmmo: 6 },
];

let cannonStates = [];

function initCannons() {
  const tx = getTurretX();
  const gy = getGroundY();
  const domeW = 130;
  const domeH = 50;
  cannonStates = cannonDefs.map(def => {
    const ratio = Math.abs(def.offset / domeW);
    const angle = Math.acos(Math.min(ratio, 0.999));
    return {
      x: tx + def.offset,
      y: gy - Math.sin(angle) * domeH,
      cooldown: def.cooldown,
      damage: def.damage,
      bulletSize: def.bulletSize,
      regenRate: def.regenRate,
      maxAmmo: def.maxAmmo,
      ammo: def.maxAmmo,
      lastShotTime: 0,
    };
  });
}

initCannons();

function getCannonPositions() {
  return cannonStates;
}

function drawTurret(time) {
  const cannons = getCannonPositions();

  for (const c of cannons) {
    const aimAngle = Math.atan2(mouseY - c.y, mouseX - c.x);
    const hasAmmo = c.ammo >= 1;
    const tint = hasAmmo ? '#00ff88' : '#334444';
    const barrelLen = c.damage >= 3 ? 28 : 22;
    const barrelW = c.damage >= 3 ? 7 : 5;
    const mountR = c.damage >= 3 ? 10 : 8;

    // Cannon base mount
    ctx.fillStyle = '#1a2a3a';
    ctx.strokeStyle = tint;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(c.x, c.y + 3, mountR, Math.PI, 0);
    ctx.fill();
    ctx.stroke();

    // Cannon barrel
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(aimAngle);

    ctx.fillStyle = '#2a3a4a';
    ctx.fillRect(0, -barrelW / 2, barrelLen, barrelW);
    ctx.strokeStyle = tint;
    ctx.lineWidth = 0.8;
    ctx.strokeRect(0, -barrelW / 2, barrelLen, barrelW);

    // Barrel tip glow
    ctx.shadowColor = tint;
    ctx.shadowBlur = hasAmmo ? 6 : 0;
    ctx.fillStyle = tint;
    ctx.fillRect(barrelLen - 2, -barrelW / 2 + 1, 3, barrelW - 2);
    ctx.shadowBlur = 0;

    ctx.restore();

    // Pivot
    ctx.fillStyle = tint;
    ctx.shadowColor = tint;
    ctx.shadowBlur = hasAmmo ? 4 : 0;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawMeteor(m, time) {
  ctx.save();

  // Fire trail particles
  for (let i = 0; i < 3; i++) {
    const trailX = m.x - m.vx * (i * 4 + Math.random() * 6);
    const trailY = m.y - m.vy * (i * 4 + Math.random() * 6);
    const trailR = m.r * (1 - i * 0.25) * (0.3 + Math.random() * 0.4);
    const alpha = (1 - i * 0.3) * 0.5;
    ctx.fillStyle = `rgba(255,${100 + i * 50},0,${alpha})`;
    ctx.beginPath();
    ctx.arc(trailX, trailY, trailR, 0, Math.PI * 2);
    ctx.fill();
  }

  // Meteor body
  ctx.translate(m.x, m.y);
  ctx.rotate(m.rotation);

  // Outer glow
  ctx.shadowColor = m.color;
  ctx.shadowBlur = 15;

  // Rocky body
  ctx.fillStyle = m.color;
  ctx.beginPath();
  const segments = m.isBoss ? 12 : 8;
  for (let i = 0; i < segments; i++) {
    const angle = (i / segments) * Math.PI * 2;
    const variation = m.shape[i % m.shape.length];
    const r = m.r * variation;
    if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
    else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
  }
  ctx.closePath();
  ctx.fill();

  // Inner darker detail
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.arc(m.r * -0.2, m.r * -0.15, m.r * 0.35, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(m.r * 0.25, m.r * 0.2, m.r * 0.2, 0, Math.PI * 2);
  ctx.fill();

  ctx.shadowBlur = 0;

  // Boss HP indicator
  if (m.isBoss && m.hp > 1) {
    ctx.fillStyle = '#ff2244';
    ctx.font = 'bold 14px Orbitron';
    ctx.textAlign = 'center';
    ctx.fillText(`${m.hp}`, 0, 5);
  }

  ctx.restore();
}

function drawLaser(l) {
  ctx.save();

  // Draw each bullet particle in the burst
  for (const b of l.bullets) {
    if (b.hit || b.offscreen) continue;
    // Trail
    ctx.fillStyle = 'rgba(0,255,136,0.15)';
    ctx.beginPath();
    ctx.arc(b.x - b.vx * 2, b.y - b.vy * 2, b.size * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Main particle
    ctx.fillStyle = `rgba(0,255,${100 + Math.floor(Math.random() * 56)},0.9)`;
    ctx.shadowColor = '#00ff88';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();

    // Core glow
    ctx.fillStyle = 'rgba(200,255,230,0.8)';
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawExplosion(e) {
  const progress = e.age / e.maxAge;
  const alpha = 1 - progress;

  ctx.save();

  // Outer ring
  ctx.strokeStyle = `rgba(0,255,136,${alpha * 0.6})`;
  ctx.lineWidth = 2;
  ctx.shadowColor = '#00ff88';
  ctx.shadowBlur = 10 * alpha;
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius * progress * 1.5, 0, Math.PI * 2);
  ctx.stroke();

  // Inner flash
  if (progress < 0.3) {
    const flashAlpha = (1 - progress / 0.3) * 0.4;
    const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius * 0.8);
    grad.addColorStop(0, `rgba(255,255,255,${flashAlpha})`);
    grad.addColorStop(0.5, `rgba(0,255,136,${flashAlpha * 0.5})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius * 0.8, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawParticle(p) {
  const alpha = 1 - p.age / p.maxAge;
  ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${alpha})`;
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
  ctx.fill();
}

function drawFloatingText(ft) {
  const alpha = 1 - ft.age / ft.maxAge;
  ctx.save();
  ctx.font = `bold ${ft.size}px Orbitron`;
  ctx.textAlign = 'center';
  ctx.fillStyle = `rgba(${ft.r},${ft.g},${ft.b},${alpha})`;
  ctx.shadowColor = `rgba(${ft.r},${ft.g},${ft.b},0.5)`;
  ctx.shadowBlur = 8;
  ctx.fillText(ft.text, ft.x, ft.y);
  ctx.shadowBlur = 0;
  ctx.restore();
}

// ─── SPAWNING ───
function createMeteor(type, x, targetX, y) {
  const cfg = CFG.meteorSizes[type];
  const startX = x !== undefined ? x : Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
  const startY = y !== undefined ? y : -cfg.r - 20;
  const tX = targetX !== undefined ? targetX : getTurretX() + (Math.random() - 0.5) * 200;
  const tY = getGroundY();

  const dx = tX - startX;
  const dy = tY - startY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const speedMult = 1 + (wave - 1) * CFG.waveSpeedMultiplier;

  const shape = [];
  const segs = type === 'boss' ? 12 : 8;
  for (let i = 0; i < segs; i++) shape.push(0.75 + Math.random() * 0.5);

  return {
    x: startX,
    y: startY,
    vx: (dx / dist) * cfg.speed * speedMult,
    vy: (dy / dist) * cfg.speed * speedMult,
    r: cfg.r,
    color: cfg.color,
    points: cfg.points,
    type: type,
    rotation: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.05,
    shape: shape,
    isBoss: type === 'boss',
    hp: cfg.hp || 1,
  };
}

function spawnWaveMeteors() {
  if (waveMetorsRemaining <= 0 && meteors.length === 0 && !wavePaused) {
    wave++;
    startWave();
    return;
  }

  if (waveMetorsRemaining <= 0 || wavePaused) return;

  waveMetorsRemaining--;

  // Determine meteor type — each wave gets wave-number bosses at the end
  let type;
  if (waveMetorsRemaining <= wave) {
    type = 'boss';
  } else {
    const roll = Math.random();
    if (roll < 0.4) type = 'small';
    else if (roll < 0.8) type = 'medium';
    else type = 'large';
  }

  meteors.push(createMeteor(type));
}

function startWave() {
  const totalMeteors = CFG.waveBaseMeteors + (wave - 1) * CFG.waveMeteorIncrease;
  waveMetorsRemaining = totalMeteors;
  waveSpawnInterval = Math.max(400, 2000 - wave * 80);
  waveSpawnTimer = 0;
  wavePaused = false;
}

function createExplosion(x, y, radius, isMeteor) {
  explosions.push({
    x, y,
    radius: radius || CFG.blastRadius,
    age: 0,
    maxAge: 500,
  });

  // Particles
  const count = isMeteor ? 20 : 12;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 1;
    const isGreen = !isMeteor || Math.random() > 0.5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      r: isGreen ? 0 : 255,
      g: isGreen ? 255 : Math.floor(Math.random() * 150 + 50),
      b: isGreen ? 136 : 0,
      size: Math.random() * 4 + 1,
      age: 0,
      maxAge: Math.random() * 600 + 200,
    });
  }
}

function createFloatingText(x, y, text, r, g, b, size) {
  floatingTexts.push({
    x, y, text,
    r: r || 0, g: g || 255, b: b || 136,
    size: size || 16,
    vy: -1.5,
    age: 0,
    maxAge: 1000,
  });
}

// ─── SHOOTING ───
function shoot(targetX, targetY) {
  if (gameState !== 'playing') return;

  const now = performance.now();
  let anyFired = false;

  for (const c of cannonStates) {
    if (c.ammo < 1) continue;
    if (now - c.lastShotTime < c.cooldown) continue;

    c.lastShotTime = now;
    c.ammo = Math.max(0, c.ammo - 1);

    const tipDist = 24;
    const aimAngle = Math.atan2(targetY - c.y, targetX - c.x);
    const sx = c.x + Math.cos(aimAngle) * tipDist;
    const sy = c.y + Math.sin(aimAngle) * tipDist;

    const spread = 0.08;
    const angleOff = (Math.random() - 0.5) * spread;
    const speedVar = 0.9 + Math.random() * 0.2;
    const bAngle = aimAngle + angleOff;
    const spd = CFG.laserSpeed * speedVar;

    const bullet = {
      x: sx, y: sy,
      vx: Math.cos(bAngle) * spd,
      vy: Math.sin(bAngle) * spd,
      size: c.bulletSize,
      damage: c.damage,
      age: 0, maxAge: 800,
    };

    lasers.push({
      sx: c.x, sy: c.y,
      x: c.x, y: c.y,
      vx: Math.cos(aimAngle) * CFG.laserSpeed,
      vy: Math.sin(aimAngle) * CFG.laserSpeed,
      targetX, targetY,
      dist: Math.sqrt((targetX - c.x) ** 2 + (targetY - c.y) ** 2),
      traveled: 0,
      bullets: [bullet],
    });

    anyFired = true;
  }

  if (anyFired) flashAlpha = 0.1;
}

function checkBulletCollisions(l) {
  // Check each bullet particle against all meteors
  let hitAny = false;

  for (let bi = l.bullets.length - 1; bi >= 0; bi--) {
    const b = l.bullets[bi];
    if (b.hit) continue;

    for (let mi = meteors.length - 1; mi >= 0; mi--) {
      const m = meteors[mi];
      const dx = m.x - b.x;
      const dy = m.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < m.r + b.size + 4) {
        // Bullet hit meteor
        b.hit = true;
        m.hp -= b.damage || 1;

        // Small impact effect at bullet position
        for (let p = 0; p < 4; p++) {
          const angle = Math.random() * Math.PI * 2;
          const spd = Math.random() * 2 + 1;
          particles.push({
            x: b.x, y: b.y,
            vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
            r: 0, g: 255, b: 136,
            size: Math.random() * 2 + 1,
            age: 0, maxAge: 300,
          });
        }

        if (m.hp <= 0) {
          destroyMeteor(m, mi);
          hitAny = true;
        } else {
          createFloatingText(m.x, m.y - m.r, `HP ${m.hp}`, 255, 34, 68, 14);
          shakeTime = 100;
          shakeIntensity = 3;
        }
        break;
      }
    }
  }

  if (hitAny) {
    const now = performance.now();
    if (now - lastComboTime < CFG.comboTimeLimit) {
      combo++;
    } else {
      combo = 1;
    }
    lastComboTime = now;
  }
}

function checkLaserHit(l) {
  // Check bullet collisions along the path every frame
  checkBulletCollisions(l);

  // Remove laser when all bullets are offscreen or hit something
  const allDone = l.bullets.every(b => b.hit || b.offscreen);
  return allDone;
}

function destroyMeteor(m, index) {
  // Score with combo
  const comboMult = Math.max(1, combo);
  const points = m.points * comboMult;
  score += points;

  createExplosion(m.x, m.y, m.r * 1.5, true);

  // Floating score text
  const comboText = comboMult > 1 ? ` x${comboMult}` : '';
  createFloatingText(m.x, m.y - 20, `+${points}${comboText}`, 0, 255, 136, comboMult > 1 ? 20 : 16);

  // Split chain: boss → 2 large → 2 medium → 2 small (small doesn't split)
  const splitMap = { boss: 'large', large: 'medium', medium: 'small' };
  const splitType = splitMap[m.type];
  if (splitType) {
    for (let s = 0; s < 2; s++) {
      const tX = m.x + (s === 0 ? -1 : 1) * (80 + Math.random() * 100);
      meteors.push(createMeteor(splitType, m.x, tX, m.y));
    }
  }

  meteors.splice(index, 1);
}

// ─── METEOR HIT BASE ───
function meteorHitBase(m, index) {
  baseHealth--;
  shakeTime = 300;
  shakeIntensity = 12;
  flashAlpha = 0.3;

  createExplosion(m.x, getGroundY(), m.r * 2, true);
  createFloatingText(getTurretX(), getGroundY() - 40, 'IMPACTO!', 255, 34, 68, 22);

  // Extra particles for base hit
  for (let i = 0; i < 30; i++) {
    const angle = -Math.PI * Math.random();
    const speed = Math.random() * 5 + 2;
    particles.push({
      x: m.x, y: getGroundY(),
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      r: 255, g: Math.floor(Math.random() * 100), b: 0,
      size: Math.random() * 5 + 2,
      age: 0,
      maxAge: Math.random() * 800 + 300,
    });
  }

  meteors.splice(index, 1);

  if (baseHealth <= 0) {
    gameOver();
  }
}

// ─── GAME FLOW ───
function startGame() {
  gameState = 'playing';
  score = 0;
  wave = 1;
  baseHealth = CFG.baseHealth;
  initCannons();
  combo = 0;
  lastComboTime = 0;
  meteors = [];
  lasers = [];
  explosions = [];
  particles = [];
  floatingTexts = [];
  shakeTime = 0;
  flashAlpha = 0;

  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('gameover-screen').classList.add('hidden');
  document.getElementById('hud').style.opacity = '1';

  document.getElementById('highscore-hud').textContent = highScore;

  startWave();
}

function gameOver() {
  gameState = 'dead';

  if (score > highScore) {
    highScore = score;
    localStorage.setItem('lunarBaseHighScore', highScore);
  }

  document.getElementById('hud').style.opacity = '0';

  setTimeout(() => {
    document.getElementById('final-score').textContent = `Pontuação: ${score}`;
    document.getElementById('final-wave').textContent = `Ondas Sobrevividas: ${wave}`;
    document.getElementById('final-record').textContent = score >= highScore ? '★ NOVO RECORDE! ★' : `Recorde: ${highScore}`;
    document.getElementById('gameover-screen').classList.remove('hidden');
  }, 800);
}

// ─── UPDATE ───
function update(dt, time) {
  if (gameState !== 'playing') return;

  // Turret rotation toward mouse
  const tx = getTurretX();
  const ty = getTurretY();
  const targetAngle = Math.atan2(mouseY - ty, mouseX - tx);
  // Clamp to upper half
  const clampedAngle = Math.max(-Math.PI + 0.1, Math.min(-0.1, targetAngle));
  turretAngle += (clampedAngle - turretAngle) * 0.15;

  // Per-cannon ammo regen
  for (const c of cannonStates) {
    c.ammo = Math.min(c.maxAmmo, c.ammo + c.regenRate * dt / 1000);
  }

  // Wave announce timer
  if (waveAnnounceTimer > 0) {
    waveAnnounceTimer -= dt;
    if (waveAnnounceTimer <= 0) {
      document.getElementById('wave-announce').classList.add('hidden');
      wavePaused = false;
    }
  }

  // Wave spawning
  if (!wavePaused) {
    waveSpawnTimer += dt;
    if (waveSpawnTimer >= waveSpawnInterval && waveMetorsRemaining > 0) {
      waveSpawnTimer = 0;
      spawnWaveMeteors();
    }

    // Check if wave is done
    if (waveMetorsRemaining <= 0 && meteors.length === 0) {
      wave++;
      startWave();
    }
  }

  // Update meteors
  for (let i = meteors.length - 1; i >= 0; i--) {
    const m = meteors[i];
    m.x += m.vx;
    m.y += m.vy;
    m.rotation += m.rotSpeed;

    // Check if meteor hit ground/base
    if (m.y + m.r >= getGroundY()) {
      const distToBase = Math.abs(m.x - getTurretX());
      if (distToBase < 100) {
        meteorHitBase(m, i);
      } else {
        // Hit ground but not base - just explode
        createExplosion(m.x, getGroundY(), m.r, true);
        meteors.splice(i, 1);
      }
    }

    // Off screen
    if (m.x < -100 || m.x > canvas.width + 100 || m.y > canvas.height + 100) {
      meteors.splice(i, 1);
    }
  }

  // Update lasers
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    const step = Math.sqrt(l.vx * l.vx + l.vy * l.vy);
    l.x += l.vx;
    l.y += l.vy;
    l.traveled += step;

    // Update bullet particles
    for (const b of l.bullets) {
      if (b.hit || b.offscreen) continue;
      b.x += b.vx;
      b.y += b.vy;
      b.age += dt;
      // Mark as offscreen if exited the viewport
      if (b.x < -20 || b.x > canvas.width + 20 || b.y < -20 || b.y > canvas.height + 20) {
        b.offscreen = true;
      }
    }

    if (checkLaserHit(l)) {
      lasers.splice(i, 1);
    }
  }

  // Update explosions
  for (let i = explosions.length - 1; i >= 0; i--) {
    explosions[i].age += dt;
    if (explosions[i].age >= explosions[i].maxAge) {
      explosions.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05;
    p.age += dt;
    if (p.age >= p.maxAge) particles.splice(i, 1);
  }

  // Update floating texts
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.y += ft.vy;
    ft.age += dt;
    if (ft.age >= ft.maxAge) floatingTexts.splice(i, 1);
  }

  // Screen shake decay
  if (shakeTime > 0) shakeTime -= dt;

  // Flash decay
  if (flashAlpha > 0) flashAlpha -= dt * 0.001;

  // Combo decay
  if (combo > 0 && performance.now() - lastComboTime > CFG.comboTimeLimit) {
    combo = 0;
  }

  // Update HUD
  document.getElementById('score-hud').textContent = score;
  document.getElementById('wave-hud').textContent = `ONDA ${wave}`;
  document.getElementById('health-bar').style.width = `${(baseHealth / CFG.baseHealth) * 100}%`;
  const totalAmmo = cannonStates.reduce((s, c) => s + c.ammo, 0);
  const totalMax = cannonStates.reduce((s, c) => s + c.maxAmmo, 0);
  document.getElementById('ammo-bar').style.width = `${(totalAmmo / totalMax) * 100}%`;

  const comboEl = document.getElementById('combo-hud');
  if (combo > 1) {
    comboEl.textContent = `COMBO x${combo}`;
    comboEl.classList.add('visible');
  } else {
    comboEl.classList.remove('visible');
  }
}

// ─── RENDER ───
function render(time) {
  ctx.save();

  // Screen shake
  if (shakeTime > 0) {
    const sx = (Math.random() - 0.5) * shakeIntensity;
    const sy = (Math.random() - 0.5) * shakeIntensity;
    ctx.translate(sx, sy);
  }

  // Clear
  ctx.fillStyle = '#0a0a12';
  ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

  // Stars
  drawStars(time);

  // Lunar surface
  drawLunarSurface();

  // Explosions (behind base)
  for (const e of explosions) drawExplosion(e);

  // Particles
  for (const p of particles) drawParticle(p);

  // Base
  drawBase();

  // Meteors
  for (const m of meteors) drawMeteor(m, time);

  // Lasers
  for (const l of lasers) drawLaser(l);

  // Turret (on top)
  drawTurret(time);

  // Floating texts
  for (const ft of floatingTexts) drawFloatingText(ft);

  // Screen flash
  if (flashAlpha > 0) {
    ctx.fillStyle = `rgba(0,255,136,${flashAlpha})`;
    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
  }

  ctx.restore();

  // Crosshair (not affected by shake)
  if (gameState === 'playing') {
    ctx.strokeStyle = 'rgba(0,255,136,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 12, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(mouseX - 18, mouseY);
    ctx.lineTo(mouseX - 8, mouseY);
    ctx.moveTo(mouseX + 8, mouseY);
    ctx.lineTo(mouseX + 18, mouseY);
    ctx.moveTo(mouseX, mouseY - 18);
    ctx.lineTo(mouseX, mouseY - 8);
    ctx.moveTo(mouseX, mouseY + 8);
    ctx.lineTo(mouseX, mouseY + 18);
    ctx.stroke();

    // Dot center
    ctx.fillStyle = 'rgba(0,255,136,0.8)';
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ─── GAME LOOP ───
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min(timestamp - lastTime, 50);
  lastTime = timestamp;

  update(dt, timestamp);
  render(timestamp);

  requestAnimationFrame(gameLoop);
}

// ─── INPUT ───
let pointerDown = false;

function handlePointerDown(x, y) {
  if (gameState === 'start') {
    startGame();
    return;
  }
  if (gameState === 'playing') {
    pointerDown = true;
    shoot(x, y);
  }
}

function handlePointerUp() {
  pointerDown = false;
}

// Autofire loop - shoots while pointer is held
function autofireCheck() {
  if (pointerDown && gameState === 'playing') {
    shoot(mouseX, mouseY);
  }
  requestAnimationFrame(autofireCheck);
}
requestAnimationFrame(autofireCheck);

canvas.addEventListener('mousedown', (e) => {
  handlePointerDown(e.clientX, e.clientY);
});

canvas.addEventListener('mouseup', handlePointerUp);
document.addEventListener('mouseup', handlePointerUp);

canvas.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  mouseX = t.clientX;
  mouseY = t.clientY;
  handlePointerDown(t.clientX, t.clientY);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  mouseX = t.clientX;
  mouseY = t.clientY;
}, { passive: false });

canvas.addEventListener('touchend', handlePointerUp);
canvas.addEventListener('touchcancel', handlePointerUp);

document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('touchstart', (e) => {
  e.preventDefault();
  e.stopPropagation();
  startGame();
});

// Prevent scroll
document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

// ─── INIT ───
document.getElementById('highscore-hud').textContent = highScore;
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
