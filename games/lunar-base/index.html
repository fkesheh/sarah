<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Lunar Base - Defenda sua Base!</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    background: #0a0a12;
    font-family: 'Share Tech Mono', monospace;
    user-select: none;
    cursor: crosshair;
    touch-action: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    overscroll-behavior: none;
  }

  html { overscroll-behavior: none; }

  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
  }

  /* ─── CRT Scanline Overlay ─── */
  .crt-overlay {
    position: fixed; inset: 0;
    pointer-events: none; z-index: 200;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.08) 2px,
      rgba(0,0,0,0.08) 4px
    );
  }

  .crt-overlay::after {
    content: '';
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
    pointer-events: none;
  }

  /* ─── HUD ─── */
  .hud {
    position: fixed; top: 0; left: 0; right: 0;
    z-index: 100; pointer-events: none;
    padding: 16px 24px;
    padding-left: 100px;
    display: flex; justify-content: space-between; align-items: flex-start;
  }

  .hud-left, .hud-right, .hud-center {
    display: flex; flex-direction: column; gap: 6px;
  }

  .hud-center {
    align-items: center;
    position: absolute; left: 50%; transform: translateX(-50%);
  }

  .hud-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    color: rgba(0,255,136,0.5);
    text-transform: uppercase;
    letter-spacing: 3px;
  }

  .hud-value {
    font-family: 'Orbitron', monospace;
    font-size: 24px;
    color: #00ff88;
    text-shadow: 0 0 10px rgba(0,255,136,0.6), 0 0 30px rgba(0,255,136,0.2);
  }

  .hud-value.score-value { font-size: 32px; }

  .hud-bar-container {
    width: 120px; height: 8px;
    background: rgba(0,255,136,0.1);
    border: 1px solid rgba(0,255,136,0.3);
    border-radius: 2px;
    overflow: hidden;
  }

  .hud-bar {
    height: 100%;
    transition: width 0.3s ease;
    border-radius: 1px;
  }

  .health-bar { background: linear-gradient(90deg, #ff2244, #ff6644); box-shadow: 0 0 8px rgba(255,34,68,0.5); }
  .ammo-bar { background: linear-gradient(90deg, #00ff88, #00ccff); box-shadow: 0 0 8px rgba(0,255,136,0.5); }

  .hud-right { align-items: flex-end; }

  .wave-display {
    font-family: 'Orbitron', monospace;
    font-size: 14px;
    color: #ff8800;
    text-shadow: 0 0 8px rgba(255,136,0,0.5);
  }

  .combo-display {
    font-family: 'Orbitron', monospace;
    font-size: 14px;
    color: #ffcc00;
    text-shadow: 0 0 8px rgba(255,204,0,0.5);
    opacity: 0;
    transition: opacity 0.3s;
  }

  .combo-display.visible { opacity: 1; }

  /* ─── Screens ─── */
  .screen-overlay {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 150;
    transition: opacity 0.6s;
  }

  .screen-overlay.hidden {
    opacity: 0; pointer-events: none;
  }

  .title-text {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: clamp(36px, 10vw, 80px);
    color: #00ff88;
    text-shadow:
      0 0 20px rgba(0,255,136,0.8),
      0 0 60px rgba(0,255,136,0.4),
      0 0 100px rgba(0,255,136,0.2),
      4px 4px 0 rgba(0,0,0,0.8);
    letter-spacing: 6px;
    animation: titlePulse 3s ease-in-out infinite;
    text-align: center;
  }

  .subtitle-text {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(12px, 3vw, 18px);
    color: rgba(255,136,0,0.9);
    text-shadow: 0 0 10px rgba(255,136,0,0.5);
    letter-spacing: 8px;
    text-transform: uppercase;
    margin-top: 16px;
    animation: subtitleFlicker 4s ease-in-out infinite;
  }

  .instruction-text {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(14px, 2.5vw, 20px);
    color: rgba(0,255,136,0.7);
    margin-top: 48px;
    letter-spacing: 2px;
    animation: blink 2.5s ease-in-out infinite;
  }

  .game-over-score {
    font-family: 'Orbitron', monospace;
    font-size: clamp(20px, 5vw, 36px);
    color: #00ff88;
    text-shadow: 0 0 15px rgba(0,255,136,0.6);
    margin-top: 24px;
  }

  .game-over-detail {
    font-family: 'Share Tech Mono', monospace;
    font-size: 16px;
    color: rgba(0,255,136,0.6);
    margin-top: 8px;
  }

  .restart-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 18px;
    color: #0a0a12;
    background: #00ff88;
    border: none;
    padding: 14px 40px;
    margin-top: 32px;
    cursor: pointer;
    letter-spacing: 3px;
    text-transform: uppercase;
    box-shadow: 0 0 20px rgba(0,255,136,0.4), 0 0 60px rgba(0,255,136,0.1);
    transition: all 0.2s;
  }

  .restart-btn:hover {
    background: #44ffaa;
    box-shadow: 0 0 30px rgba(0,255,136,0.6), 0 0 80px rgba(0,255,136,0.2);
    transform: scale(1.05);
  }

  .restart-btn:active { transform: scale(0.97); }

  .back-link {
    position: fixed; top: 12px; left: 12px; z-index: 300;
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px; color: rgba(0,255,136,0.5);
    text-decoration: none;
    padding: 6px 14px;
    border: 1px solid rgba(0,255,136,0.2);
    border-radius: 4px;
    transition: all 0.2s;
    background: rgba(10,10,18,0.7);
  }

  .back-link:hover {
    color: #00ff88;
    border-color: rgba(0,255,136,0.5);
    background: rgba(10,10,18,0.9);
  }

  @keyframes titlePulse {
    0%, 100% { text-shadow: 0 0 20px rgba(0,255,136,0.8), 0 0 60px rgba(0,255,136,0.4), 0 0 100px rgba(0,255,136,0.2), 4px 4px 0 rgba(0,0,0,0.8); }
    50% { text-shadow: 0 0 30px rgba(0,255,136,1), 0 0 80px rgba(0,255,136,0.6), 0 0 120px rgba(0,255,136,0.3), 4px 4px 0 rgba(0,0,0,0.8); }
  }

  @keyframes subtitleFlicker {
    0%, 100% { opacity: 0.9; }
    50% { opacity: 0.75; }
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  @media (max-width: 640px) {
    .hud { padding: 10px 14px; }
    .hud-value { font-size: 18px; }
    .hud-value.score-value { font-size: 22px; }
    .hud-bar-container { width: 80px; height: 6px; }
    .hud-label { font-size: 8px; letter-spacing: 2px; }
    .wave-display { font-size: 12px; }
  }
</style>
</head>
<body>

<a href="../../" class="back-link">← MENU</a>

<canvas id="game-canvas"></canvas>
<div class="crt-overlay"></div>

<!-- HUD -->
<div class="hud" id="hud" style="opacity: 0;">
  <div class="hud-left">
    <div class="hud-label">Pontuação</div>
    <div class="hud-value score-value" id="score-hud">0</div>
    <div class="hud-label" style="margin-top: 8px;">Recorde</div>
    <div class="hud-value" id="highscore-hud" style="font-size: 14px; opacity: 0.6;">0</div>
  </div>
  <div class="hud-center">
    <div class="wave-display" id="wave-hud">ONDA 1</div>
    <div class="combo-display" id="combo-hud">COMBO x2</div>
  </div>
  <div class="hud-right">
    <div class="hud-label">Base</div>
    <div class="hud-bar-container">
      <div class="hud-bar health-bar" id="health-bar" style="width: 100%;"></div>
    </div>
    <div class="hud-label" style="margin-top: 8px;">Energia</div>
    <div class="hud-bar-container">
      <div class="hud-bar ammo-bar" id="ammo-bar" style="width: 100%;"></div>
    </div>
  </div>
</div>

<!-- Start Screen -->
<div class="screen-overlay" id="start-screen">
  <div class="title-text">LUNAR<br>BASE</div>
  <div class="subtitle-text">Defenda sua base</div>
  <div class="instruction-text">[ CLIQUE PARA ATIRAR ]</div>
</div>

<!-- Game Over Screen -->
<div class="screen-overlay hidden" id="gameover-screen">
  <div class="title-text" style="font-size: clamp(28px, 7vw, 56px); color: #ff2244; text-shadow: 0 0 20px rgba(255,34,68,0.8), 0 0 60px rgba(255,34,68,0.4), 4px 4px 0 rgba(0,0,0,0.8);">
    GAME OVER
  </div>
  <div class="game-over-score" id="final-score">0</div>
  <div class="game-over-detail" id="final-wave">Ondas Sobrevividas: 0</div>
  <div class="game-over-detail" id="final-record"></div>
  <button class="restart-btn" id="restart-btn">JOGAR NOVAMENTE</button>
</div>

<!-- Wave Announcement -->
<div class="screen-overlay hidden" id="wave-announce" style="pointer-events: none;">
  <div class="wave-display" style="font-size: clamp(28px, 8vw, 56px); letter-spacing: 6px;" id="wave-announce-text">ONDA 1</div>
</div>

<script>
// ─── CANVAS SETUP ───
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ─── GAME CONFIG ───
const CFG = {
  baseHealth: 5,
  maxAmmo: 8,
  ammoRegenRate: 3,
  laserSpeed: 14,
  laserCooldown: 250,
  blastRadius: 55,
  meteorSizes: {
    small:  { r: 10, speed: 2.8, points: 10, baseHp: 1 },
    medium: { r: 20, speed: 1.8, points: 25, baseHp: 2 },
    large:  { r: 32, speed: 1.2, points: 50, baseHp: 4 },
    boss:   { r: 52, speed: 0.8, points: 200, baseHp: 8 },
  },
  // Material classes: hp multiplier, colors, trail color
  meteorMaterials: {
    ice:   { hpMult: 1, color: '#88ccff', glow: '#44aaff', trail: [136, 200, 255], label: 'ICE' },
    rock:  { hpMult: 2, color: '#ff8844', glow: '#ff6622', trail: [255, 100, 0], label: 'ROCK' },
    metal: { hpMult: 3, color: '#ccccdd', glow: '#aaaacc', trail: [200, 200, 220], label: 'METAL' },
  },
  waveBaseMeteors: 3,
  waveMeteorIncrease: 1,
  waveSpeedMultiplier: 0.04,
  bossWaveInterval: 5,
  splitWaveThreshold: 10,
  groundY: 0.88,
  turretY: 0.84,
  comboTimeLimit: 2000,
  domeR: 65,
};

// ─── GAME STATE ───
let gameState = 'start';
let score = 0;
let highScore = parseInt(localStorage.getItem('lunarBaseHighScore')) || 0;
let wave = 1;
let baseHealth = CFG.baseHealth;
let ammo = CFG.maxAmmo;
let lastShotTime = 0;
let combo = 0;
let lastComboTime = 0;
let shakeTime = 0;
let shakeIntensity = 0;
let flashAlpha = 0;

let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;
let turretAngle = -Math.PI / 2;

let meteors = [];
let lasers = [];
let explosions = [];
let particles = [];
let floatingTexts = [];
let stars = [];
let bonusItems = [];
let groundItems = [];

// ─── BONUS ITEM CONFIG ───
const BONUS_TYPES = {
  turret: { color: '#00ff88', glow: '#00ff88', label: 'TURRET', speed: 1.0, r: 18 },
  battery: { color: '#4488ff', glow: '#2266ff', label: 'BATTERY', speed: 1.0, r: 16 },
  solar: { color: '#ffcc00', glow: '#ffaa00', label: 'SOLAR', speed: 1.0, r: 16 },
};

// Activation order from center outward: index 3 (center) → 2,4 → 1,5 → 0,6
const CANNON_ACTIVATION_ORDER = [3, 2, 4, 1, 5, 0, 6];

let waveMetorsRemaining = 0;
let waveSpawnTimer = 0;
let waveSpawnInterval = 2000;
let waveActive = false;
let wavePaused = false;
let waveAnnounceTimer = 0;
let bonusSpawnTimer = 0;
let bonusSpawnInterval = 8000; // mid-wave bonus every 8 seconds
let waveBonusCount = 0; // bonuses spawned this wave

// ─── STARS BACKGROUND ───
function initStars() {
  stars = [];
  for (let i = 0; i < 200; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * CFG.groundY,
      size: Math.random() * 2 + 0.5,
      twinkleSpeed: Math.random() * 0.002 + 0.0005,
      twinkleOffset: Math.random() * Math.PI * 2,
      brightness: Math.random() * 0.5 + 0.3,
    });
  }
}
initStars();

// ─── DRAWING HELPERS ───
function getGroundY() { return canvas.height * CFG.groundY; }
function getTurretX() { return canvas.width / 2; }
function getTurretY() { return getGroundY(); }

function drawStars(time) {
  for (const s of stars) {
    const alpha = s.brightness + Math.sin(time * s.twinkleSpeed + s.twinkleOffset) * 0.3;
    ctx.fillStyle = `rgba(200,220,255,${Math.max(0.05, alpha)})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawLunarSurface() {
  const gy = getGroundY();
  const w = canvas.width;
  const h = canvas.height;

  // Main surface
  ctx.fillStyle = '#1a1a2a';
  ctx.fillRect(0, gy, w, h - gy);

  // Surface line with glow
  ctx.strokeStyle = 'rgba(0,255,136,0.3)';
  ctx.lineWidth = 2;
  ctx.shadowColor = 'rgba(0,255,136,0.3)';
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.moveTo(0, gy);

  // Uneven terrain
  for (let x = 0; x <= w; x += 40) {
    const yOff = Math.sin(x * 0.008) * 4 + Math.sin(x * 0.02) * 2;
    ctx.lineTo(x, gy + yOff);
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Craters
  const craters = [
    { x: w * 0.15, y: gy + 30, r: 25 },
    { x: w * 0.35, y: gy + 45, r: 18 },
    { x: w * 0.65, y: gy + 35, r: 22 },
    { x: w * 0.82, y: gy + 50, r: 15 },
    { x: w * 0.92, y: gy + 25, r: 12 },
  ];

  for (const c of craters) {
    ctx.fillStyle = 'rgba(10,10,20,0.6)';
    ctx.beginPath();
    ctx.ellipse(c.x, c.y, c.r, c.r * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(0,255,136,0.08)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.ellipse(c.x, c.y, c.r, c.r * 0.4, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
}

function drawBase() {
  const tx = getTurretX();
  const gy = getGroundY();
  const damage = 1 - baseHealth / CFG.baseHealth;

  // Base dome
  const domeR = CFG.domeR;

  ctx.save();

  // Dome glow
  const domeGrad = ctx.createRadialGradient(tx, gy - 5, 10, tx, gy - 5, domeR);
  domeGrad.addColorStop(0, 'rgba(0,255,136,0.08)');
  domeGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = domeGrad;
  ctx.fillRect(tx - domeR, gy - domeR - 20, domeR * 2, domeR + 25);

  // Dome body
  ctx.fillStyle = `rgba(20,30,40,0.95)`;
  ctx.beginPath();
  ctx.arc(tx, gy, domeR, Math.PI, 0);
  ctx.fill();

  // Dome outline
  const outlineColor = damage > 0.66 ? '#ff2244' : damage > 0.33 ? '#ff8800' : '#00ff88';
  ctx.strokeStyle = outlineColor;
  ctx.lineWidth = 2;
  ctx.shadowColor = outlineColor;
  ctx.shadowBlur = 12;
  ctx.beginPath();
  ctx.arc(tx, gy, domeR, Math.PI, 0);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Dome damage cracks
  if (damage > 0) {
    ctx.strokeStyle = `rgba(255,34,68,${damage * 0.6})`;
    ctx.lineWidth = 1;
    for (let i = 0; i < Math.floor(damage * 6); i++) {
      const cx = tx + (Math.random() - 0.5) * domeR * 1.5;
      const cy = gy - Math.random() * domeR * 0.8;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + (Math.random() - 0.5) * 20, cy + Math.random() * 15);
      ctx.lineTo(cx + (Math.random() - 0.5) * 15, cy + Math.random() * 20);
      ctx.stroke();
    }
  }

  // Window lights on dome
  const windowColors = ['rgba(0,255,136,0.4)', 'rgba(0,200,255,0.3)', 'rgba(255,200,0,0.3)'];
  for (let i = -2; i <= 2; i++) {
    const wx = tx + i * 20;
    const ratio = Math.abs(i * 20 / domeR);
    if (ratio >= 1) continue;
    const angle = Math.acos(ratio);
    const wy = gy - Math.sin(angle) * domeR * 0.6;
    if (damage < 0.66 || Math.random() > 0.3) {
      ctx.fillStyle = windowColors[Math.abs(i) % windowColors.length];
      ctx.fillRect(wx - 5, wy - 4, 10, 8);
    }
  }

  ctx.restore();
}

// 7 cannons along the dome arc — each with independent stats
// Index 0,6 = outermost (fastest, weakest), index 3 = center (slow, strong)
// Activation order from center outward: 3 → 2,4 → 1,5 → 0,6
const cannonDefs = [
  { offset: -190, cooldown: 120, damage: 1, bulletSize: 1.5, regenRate: 3.2, maxAmmo: 6 },
  { offset: -145, cooldown: 150, damage: 1, bulletSize: 1.8, regenRate: 2.8, maxAmmo: 6 },
  { offset: -100, cooldown: 200, damage: 1, bulletSize: 2.2, regenRate: 2.45, maxAmmo: 5 },
  { offset:    0, cooldown: 350, damage: 3, bulletSize: 4.0, regenRate: 1.4, maxAmmo: 4 },
  { offset:  100, cooldown: 200, damage: 1, bulletSize: 2.2, regenRate: 2.45, maxAmmo: 5 },
  { offset:  145, cooldown: 150, damage: 1, bulletSize: 1.8, regenRate: 2.8, maxAmmo: 6 },
  { offset:  190, cooldown: 120, damage: 1, bulletSize: 1.5, regenRate: 3.2, maxAmmo: 6 },
];

let cannonStates = [];

function initCannons() {
  const tx = getTurretX();
  const gy = getGroundY();
  cannonStates = cannonDefs.map((def, idx) => {
    return {
      x: tx + def.offset,
      y: gy,
      cooldown: def.cooldown,
      damage: def.damage,
      bulletSize: def.bulletSize,
      regenRate: def.regenRate,
      baseRegenRate: def.regenRate,
      maxAmmo: def.maxAmmo,
      baseMaxAmmo: def.maxAmmo,
      ammo: def.maxAmmo,
      lastShotTime: 0,
      active: idx === 3,
    };
  });
}

initCannons();

function getCannonPositions() {
  return cannonStates;
}

function drawTurret(time) {
  const cannons = getCannonPositions();

  for (const c of cannons) {
    if (!c.active) continue;
    const aimAngle = Math.atan2(mouseY - c.y, mouseX - c.x);
    const hasAmmo = c.ammo >= 1;
    const tint = hasAmmo ? '#00ff88' : '#334444';
    const barrelLen = c.damage >= 3 ? 28 : 22;
    const barrelW = c.damage >= 3 ? 7 : 5;
    const mountR = c.damage >= 3 ? 10 : 8;

    // Cannon base mount
    ctx.fillStyle = '#1a2a3a';
    ctx.strokeStyle = tint;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(c.x, c.y + 3, mountR, Math.PI, 0);
    ctx.fill();
    ctx.stroke();

    // Cannon barrel
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(aimAngle);

    ctx.fillStyle = '#2a3a4a';
    ctx.fillRect(0, -barrelW / 2, barrelLen, barrelW);
    ctx.strokeStyle = tint;
    ctx.lineWidth = 0.8;
    ctx.strokeRect(0, -barrelW / 2, barrelLen, barrelW);

    // Barrel tip glow
    ctx.shadowColor = tint;
    ctx.shadowBlur = hasAmmo ? 6 : 0;
    ctx.fillStyle = tint;
    ctx.fillRect(barrelLen - 2, -barrelW / 2 + 1, 3, barrelW - 2);
    ctx.shadowBlur = 0;

    ctx.restore();

    // Pivot
    ctx.fillStyle = tint;
    ctx.shadowColor = tint;
    ctx.shadowBlur = hasAmmo ? 4 : 0;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawMeteor(m, time) {
  ctx.save();

  // Fire trail particles (material-tinted)
  const tr = m.trailRGB || [255, 100, 0];
  for (let i = 0; i < 3; i++) {
    const trailX = m.x - m.vx * (i * 4 + Math.random() * 6);
    const trailY = m.y - m.vy * (i * 4 + Math.random() * 6);
    const trailR = m.r * (1 - i * 0.25) * (0.3 + Math.random() * 0.4);
    const alpha = (1 - i * 0.3) * 0.5;
    ctx.fillStyle = `rgba(${tr[0]},${Math.min(255, tr[1] + i * 30)},${tr[2]},${alpha})`;
    ctx.beginPath();
    ctx.arc(trailX, trailY, trailR, 0, Math.PI * 2);
    ctx.fill();
  }

  // Meteor body
  ctx.translate(m.x, m.y);
  ctx.rotate(m.rotation);

  // Outer glow
  ctx.shadowColor = m.glowColor || m.color;
  ctx.shadowBlur = 15;

  // Rocky body
  ctx.fillStyle = m.color;
  ctx.beginPath();
  const segments = m.isBoss ? 12 : 8;
  for (let i = 0; i < segments; i++) {
    const angle = (i / segments) * Math.PI * 2;
    const variation = m.shape[i % m.shape.length];
    const r = m.r * variation;
    if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
    else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
  }
  ctx.closePath();
  ctx.fill();

  // Inner darker detail
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.arc(m.r * -0.2, m.r * -0.15, m.r * 0.35, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(m.r * 0.25, m.r * 0.2, m.r * 0.2, 0, Math.PI * 2);
  ctx.fill();

  ctx.shadowBlur = 0;

  // HP indicator for any meteor with more than 1 HP
  if (m.hp > 1) {
    ctx.fillStyle = m.glowColor || '#ff2244';
    ctx.font = `bold ${Math.max(10, m.r * 0.4)}px Orbitron`;
    ctx.textAlign = 'center';
    ctx.fillText(`${m.hp}`, 0, m.r * 0.15);
  }

  ctx.restore();
}

function drawLaser(l) {
  ctx.save();

  // Draw each bullet particle in the burst
  for (const b of l.bullets) {
    if (b.hit || b.offscreen) continue;
    // Trail
    ctx.fillStyle = 'rgba(0,255,136,0.15)';
    ctx.beginPath();
    ctx.arc(b.x - b.vx * 2, b.y - b.vy * 2, b.size * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Main particle
    ctx.fillStyle = `rgba(0,255,${100 + Math.floor(Math.random() * 56)},0.9)`;
    ctx.shadowColor = '#00ff88';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();

    // Core glow
    ctx.fillStyle = 'rgba(200,255,230,0.8)';
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawExplosion(e) {
  const progress = e.age / e.maxAge;
  const alpha = 1 - progress;

  ctx.save();

  // Outer ring
  ctx.strokeStyle = `rgba(0,255,136,${alpha * 0.6})`;
  ctx.lineWidth = 2;
  ctx.shadowColor = '#00ff88';
  ctx.shadowBlur = 10 * alpha;
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius * progress * 1.5, 0, Math.PI * 2);
  ctx.stroke();

  // Inner flash
  if (progress < 0.3) {
    const flashAlpha = (1 - progress / 0.3) * 0.4;
    const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius * 0.8);
    grad.addColorStop(0, `rgba(255,255,255,${flashAlpha})`);
    grad.addColorStop(0.5, `rgba(0,255,136,${flashAlpha * 0.5})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius * 0.8, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawParticle(p) {
  const alpha = 1 - p.age / p.maxAge;
  ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${alpha})`;
  ctx.beginPath();
  ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
  ctx.fill();
}

function drawFloatingText(ft) {
  const alpha = 1 - ft.age / ft.maxAge;
  ctx.save();
  ctx.font = `bold ${ft.size}px Orbitron`;
  ctx.textAlign = 'center';
  ctx.fillStyle = `rgba(${ft.r},${ft.g},${ft.b},${alpha})`;
  ctx.shadowColor = `rgba(${ft.r},${ft.g},${ft.b},0.5)`;
  ctx.shadowBlur = 8;
  ctx.fillText(ft.text, ft.x, ft.y);
  ctx.shadowBlur = 0;
  ctx.restore();
}

// ─── SPAWNING ───
function pickMaterial() {
  const roll = Math.random();
  // Early waves heavily favor ice (weaker)
  const iceChance = wave <= 3 ? 0.8 : wave <= 6 ? 0.6 : 0.5;
  if (roll < iceChance) return 'ice';
  if (roll < 0.85) return 'rock';
  return 'metal';
}

function createMeteor(type, x, targetX, y, material) {
  const cfg = CFG.meteorSizes[type];
  const resolvedMaterial = material || pickMaterial();
  const mat = CFG.meteorMaterials[resolvedMaterial];
  const startX = x !== undefined ? x : Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
  const startY = y !== undefined ? y : -cfg.r - 20;
  const tX = targetX !== undefined ? targetX : getTurretX() + (Math.random() - 0.5) * 200;
  const tY = getGroundY();

  const dx = tX - startX;
  const dy = tY - startY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const speedMult = 1 + (wave - 1) * CFG.waveSpeedMultiplier;

  const shape = [];
  const segs = type === 'boss' ? 12 : 8;
  for (let i = 0; i < segs; i++) shape.push(0.75 + Math.random() * 0.5);

  const hp = cfg.baseHp * mat.hpMult;

  return {
    x: startX,
    y: startY,
    vx: (dx / dist) * cfg.speed * speedMult,
    vy: (dy / dist) * cfg.speed * speedMult,
    r: cfg.r,
    color: mat.color,
    glowColor: mat.glow,
    trailRGB: mat.trail,
    material: resolvedMaterial,
    points: cfg.points * mat.hpMult,
    type: type,
    rotation: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.05,
    shape: shape,
    isBoss: type === 'boss',
    hp: hp,
    maxHp: hp,
  };
}

function spawnWaveMeteors() {
  if (waveMetorsRemaining <= 0 && meteors.length === 0 && !wavePaused) {
    wave++;
    startWave();
    return;
  }

  if (waveMetorsRemaining <= 0 || wavePaused) return;

  waveMetorsRemaining--;

  // Determine meteor type — bosses start at wave 3, count = Math.floor(wave/3) capped at wave
  let type;
  const bossCount = wave >= 3 ? Math.min(Math.floor(wave / 3), wave) : 0;
  if (bossCount > 0 && waveMetorsRemaining <= bossCount) {
    type = 'boss';
  } else {
    // Early waves favor small meteors
    const roll = Math.random();
    const smallChance = wave <= 3 ? 0.6 : 0.4;
    const medChance = wave <= 3 ? 0.9 : 0.8;
    if (roll < smallChance) type = 'small';
    else if (roll < medChance) type = 'medium';
    else type = 'large';
  }

  meteors.push(createMeteor(type));
}

function startWave() {
  const totalMeteors = CFG.waveBaseMeteors + (wave - 1) * CFG.waveMeteorIncrease;
  waveMetorsRemaining = totalMeteors;
  waveSpawnInterval = Math.max(500, 2500 - wave * 80);
  waveSpawnTimer = 0;
  wavePaused = false;
  waveBonusCount = 0;
  bonusSpawnTimer = 0;

  spawnBonusIfNeeded();
}

function createExplosion(x, y, radius, isMeteor) {
  explosions.push({
    x, y,
    radius: radius || CFG.blastRadius,
    age: 0,
    maxAge: 500,
  });

  // Particles
  const count = isMeteor ? 20 : 12;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 1;
    const isGreen = !isMeteor || Math.random() > 0.5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      r: isGreen ? 0 : 255,
      g: isGreen ? 255 : Math.floor(Math.random() * 150 + 50),
      b: isGreen ? 136 : 0,
      size: Math.random() * 4 + 1,
      age: 0,
      maxAge: Math.random() * 600 + 200,
    });
  }
}

function createFloatingText(x, y, text, r, g, b, size) {
  floatingTexts.push({
    x, y, text,
    r: r || 0, g: g || 255, b: b || 136,
    size: size || 16,
    vy: -1.5,
    age: 0,
    maxAge: 1000,
  });
}

// ─── BONUS ITEMS ───
function createBonusItem(type) {
  const cfg = BONUS_TYPES[type];
  const startX = Math.random() * canvas.width * 0.6 + canvas.width * 0.2;
  const startY = -cfg.r - 20;
  const tX = getTurretX() + (Math.random() - 0.5) * 300;
  const tY = getGroundY();

  const dx = tX - startX;
  const dy = tY - startY;
  const dist = Math.sqrt(dx * dx + dy * dy);

  return {
    x: startX,
    y: startY,
    vx: (dx / dist) * cfg.speed,
    vy: (dy / dist) * cfg.speed,
    r: cfg.r,
    type: type,
    color: cfg.color,
    glow: cfg.glow,
    label: cfg.label,
    pulsePhase: Math.random() * Math.PI * 2,
  };
}

function pickBonusType() {
  const activeTurrets = cannonStates.filter(c => c.active).length;
  const types = ['battery', 'solar'];
  if (activeTurrets < 7) {
    types.push('turret');
    if (activeTurrets < 3) types.push('turret', 'turret');
  }
  return types[Math.floor(Math.random() * types.length)];
}

function spawnBonusIfNeeded() {
  // Guaranteed bonus on wave start for first 5 waves, 60% after
  const chance = wave <= 5 ? 1.0 : 0.6;
  if (Math.random() > chance) return;

  bonusItems.push(createBonusItem(pickBonusType()));
  waveBonusCount++;
}

function tryMidWaveBonus() {
  // Cap mid-wave bonuses: 1 extra per wave early, 2 later
  const maxMidWave = wave <= 3 ? 1 : 2;
  if (waveBonusCount >= 1 + maxMidWave) return;

  const chance = wave <= 5 ? 0.5 : 0.35;
  if (Math.random() > chance) return;

  bonusItems.push(createBonusItem(pickBonusType()));
  waveBonusCount++;
}

function getNextGroundItemX() {
  const tx = getTurretX();
  const domeW = CFG.domeR;
  const existingCount = groundItems.length;
  const spacing = 35;
  const side = existingCount % 2 === 0 ? 1 : -1;
  const slot = Math.floor(existingCount / 2);
  return tx + side * (domeW + 20 + slot * spacing);
}

function activateNextCannon() {
  for (const idx of CANNON_ACTIVATION_ORDER) {
    if (!cannonStates[idx].active) {
      cannonStates[idx].active = true;
      cannonStates[idx].ammo = cannonStates[idx].maxAmmo;
      return true;
    }
  }
  return false;
}

function deactivateRandomTurret() {
  const activeIndices = cannonStates
    .map((c, i) => ({ active: c.active, idx: i }))
    .filter(c => c.active)
    .map(c => c.idx);

  if (activeIndices.length <= 1) return;

  const idx = activeIndices[Math.floor(Math.random() * activeIndices.length)];
  cannonStates[idx].active = false;

  createFloatingText(cannonStates[idx].x, cannonStates[idx].y - 30, '-TURRET', 255, 34, 68, 20);
  createExplosion(cannonStates[idx].x, cannonStates[idx].y, 20, false);
}

function collectBonus(item, bulletX, bulletY) {
  const type = item.type;

  if (type === 'turret') {
    if (activateNextCannon()) {
      createFloatingText(bulletX, bulletY - 20, '+TURRET', 0, 255, 136, 20);
    }
  } else if (type === 'battery') {
    for (const c of cannonStates) {
      if (c.active) {
        c.maxAmmo += 2;
        c.ammo = Math.min(c.ammo + 2, c.maxAmmo);
      }
    }
    groundItems.push({ type: 'battery', x: getNextGroundItemX(), y: getGroundY() });
    createFloatingText(bulletX, bulletY - 20, '+BATTERY', 68, 136, 255, 20);
  } else if (type === 'solar') {
    for (const c of cannonStates) {
      if (c.active) {
        c.regenRate *= 1.3;
      }
    }
    groundItems.push({ type: 'solar', x: getNextGroundItemX(), y: getGroundY() });
    createFloatingText(bulletX, bulletY - 20, '+SOLAR', 255, 204, 0, 20);
  }

  // Celebration particles (gold/cyan)
  for (let i = 0; i < 15; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 3 + 1;
    const isGold = Math.random() > 0.5;
    particles.push({
      x: bulletX, y: bulletY,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      r: isGold ? 255 : 0,
      g: isGold ? 204 : 255,
      b: isGold ? 0 : 255,
      size: Math.random() * 4 + 2,
      age: 0,
      maxAge: Math.random() * 600 + 300,
    });
  }
}

function destroyGroundItem(gi, index, meteorX) {
  if (gi.type === 'battery') {
    for (const c of cannonStates) {
      if (c.active) {
        c.maxAmmo = Math.max(c.baseMaxAmmo, c.maxAmmo - 2);
        c.ammo = Math.min(c.ammo, c.maxAmmo);
      }
    }
  } else if (gi.type === 'solar') {
    for (const c of cannonStates) {
      if (c.active) {
        c.regenRate = Math.max(c.baseRegenRate, c.regenRate / 1.3);
      }
    }
  }

  createExplosion(gi.x, gi.y, 30, true);
  createFloatingText(gi.x, gi.y - 30, 'LOST!', 255, 34, 68, 18);
  groundItems.splice(index, 1);
}

function drawBonusItem(item, time) {
  ctx.save();

  const pulse = 0.7 + Math.sin(time * 0.005 + item.pulsePhase) * 0.3;

  // Outer glow
  ctx.shadowColor = item.glow;
  ctx.shadowBlur = 20 * pulse;

  if (item.type === 'turret') {
    // Small green cannon icon: circle with a line
    ctx.fillStyle = item.color;
    ctx.globalAlpha = pulse;
    ctx.beginPath();
    ctx.arc(item.x, item.y, item.r * 0.6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = item.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(item.x, item.y);
    ctx.lineTo(item.x, item.y - item.r);
    ctx.stroke();
  } else if (item.type === 'battery') {
    // Blue rectangle with + terminal
    ctx.fillStyle = item.color;
    ctx.globalAlpha = pulse;
    ctx.fillRect(item.x - 10, item.y - 12, 20, 24);
    ctx.fillStyle = '#88bbff';
    ctx.fillRect(item.x - 4, item.y - 16, 8, 4);
    // + sign
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(item.x - 5, item.y - 2, 10, 3);
    ctx.fillRect(item.x - 1.5, item.y - 6, 3, 11);
  } else if (item.type === 'solar') {
    // Yellow grid rectangle
    ctx.fillStyle = item.color;
    ctx.globalAlpha = pulse;
    ctx.fillRect(item.x - 12, item.y - 10, 24, 20);
    // Grid lines
    ctx.strokeStyle = '#aa8800';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(item.x, item.y - 10);
    ctx.lineTo(item.x, item.y + 10);
    ctx.moveTo(item.x - 12, item.y);
    ctx.lineTo(item.x + 12, item.y);
    ctx.moveTo(item.x - 6, item.y - 10);
    ctx.lineTo(item.x - 6, item.y + 10);
    ctx.moveTo(item.x + 6, item.y - 10);
    ctx.lineTo(item.x + 6, item.y + 10);
    ctx.stroke();
  }

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Label
  ctx.font = 'bold 9px Orbitron';
  ctx.textAlign = 'center';
  ctx.fillStyle = item.color;
  ctx.fillText(item.label, item.x, item.y + item.r + 12);

  ctx.restore();
}

function drawGroundItems(time) {
  for (const gi of groundItems) {
    ctx.save();

    if (gi.type === 'battery') {
      // Small blue rectangle with terminals on the ground
      ctx.fillStyle = '#2244aa';
      ctx.fillRect(gi.x - 8, gi.y - 16, 16, 16);
      ctx.strokeStyle = '#4488ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(gi.x - 8, gi.y - 16, 16, 16);
      // Terminal on top
      ctx.fillStyle = '#6699ff';
      ctx.fillRect(gi.x - 3, gi.y - 20, 6, 4);
      // + sign
      ctx.fillStyle = '#88ccff';
      ctx.fillRect(gi.x - 3, gi.y - 10, 6, 2);
      ctx.fillRect(gi.x - 1, gi.y - 12, 2, 6);
    } else if (gi.type === 'solar') {
      // Yellow angled panel on the ground
      ctx.fillStyle = '#aa8800';
      ctx.fillRect(gi.x - 2, gi.y - 18, 4, 18);
      // Panel (angled)
      ctx.fillStyle = '#ddaa00';
      ctx.save();
      ctx.translate(gi.x, gi.y - 18);
      ctx.rotate(-0.3);
      ctx.fillRect(-10, -8, 20, 12);
      // Grid lines
      ctx.strokeStyle = '#886600';
      ctx.lineWidth = 0.8;
      ctx.beginPath();
      ctx.moveTo(0, -8);
      ctx.lineTo(0, 4);
      ctx.moveTo(-10, -2);
      ctx.lineTo(10, -2);
      ctx.stroke();
      ctx.restore();
    }

    ctx.restore();
  }
}

// ─── SHOOTING ───
function shoot(targetX, targetY) {
  if (gameState !== 'playing') return;

  const now = performance.now();
  let anyFired = false;

  for (const c of cannonStates) {
    if (!c.active) continue;
    if (c.ammo < 1) continue;
    if (now - c.lastShotTime < c.cooldown) continue;

    c.lastShotTime = now;
    c.ammo = Math.max(0, c.ammo - 1);

    const tipDist = 24;
    const aimAngle = Math.atan2(targetY - c.y, targetX - c.x);
    const sx = c.x + Math.cos(aimAngle) * tipDist;
    const sy = c.y + Math.sin(aimAngle) * tipDist;

    const spread = 0.08;
    const angleOff = (Math.random() - 0.5) * spread;
    const speedVar = 0.9 + Math.random() * 0.2;
    const bAngle = aimAngle + angleOff;
    const spd = CFG.laserSpeed * speedVar;

    const bullet = {
      x: sx, y: sy,
      vx: Math.cos(bAngle) * spd,
      vy: Math.sin(bAngle) * spd,
      size: c.bulletSize,
      damage: c.damage,
      age: 0, maxAge: 800,
    };

    lasers.push({
      sx: c.x, sy: c.y,
      x: c.x, y: c.y,
      vx: Math.cos(aimAngle) * CFG.laserSpeed,
      vy: Math.sin(aimAngle) * CFG.laserSpeed,
      targetX, targetY,
      dist: Math.sqrt((targetX - c.x) ** 2 + (targetY - c.y) ** 2),
      traveled: 0,
      bullets: [bullet],
    });

    anyFired = true;
  }

  if (anyFired) flashAlpha = 0.1;
}

function checkBulletCollisions(l) {
  // Check each bullet particle against all meteors
  let hitAny = false;

  for (let bi = l.bullets.length - 1; bi >= 0; bi--) {
    const b = l.bullets[bi];
    if (b.hit) continue;

    for (let mi = meteors.length - 1; mi >= 0; mi--) {
      const m = meteors[mi];
      const dx = m.x - b.x;
      const dy = m.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < m.r + b.size + 4) {
        // Bullet hit meteor
        b.hit = true;
        m.hp -= b.damage || 1;

        // Small impact effect at bullet position
        for (let p = 0; p < 4; p++) {
          const angle = Math.random() * Math.PI * 2;
          const spd = Math.random() * 2 + 1;
          particles.push({
            x: b.x, y: b.y,
            vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
            r: 0, g: 255, b: 136,
            size: Math.random() * 2 + 1,
            age: 0, maxAge: 300,
          });
        }

        if (m.hp <= 0) {
          destroyMeteor(m, mi);
          hitAny = true;
        } else {
          createFloatingText(m.x, m.y - m.r, `HP ${m.hp}`, 255, 34, 68, 14);
          shakeTime = 100;
          shakeIntensity = 3;
        }
        break;
      }
    }
  }

  // Check bullets against bonus items
  for (let bi = l.bullets.length - 1; bi >= 0; bi--) {
    const b = l.bullets[bi];
    if (b.hit) continue;

    for (let boi = bonusItems.length - 1; boi >= 0; boi--) {
      const item = bonusItems[boi];
      const dx = item.x - b.x;
      const dy = item.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < item.r + b.size + 4) {
        b.hit = true;
        collectBonus(item, item.x, item.y);
        bonusItems.splice(boi, 1);
        break;
      }
    }
  }

  if (hitAny) {
    const now = performance.now();
    if (now - lastComboTime < CFG.comboTimeLimit) {
      combo++;
    } else {
      combo = 1;
    }
    lastComboTime = now;
  }
}

function checkLaserHit(l) {
  // Check bullet collisions along the path every frame
  checkBulletCollisions(l);

  // Remove laser when all bullets are offscreen or hit something
  const allDone = l.bullets.every(b => b.hit || b.offscreen);
  return allDone;
}

function destroyMeteor(m, index) {
  // Score with combo
  const comboMult = Math.max(1, combo);
  const points = m.points * comboMult;
  score += points;

  createExplosion(m.x, m.y, m.r * 1.5, true);

  // Floating score text
  const comboText = comboMult > 1 ? ` x${comboMult}` : '';
  createFloatingText(m.x, m.y - 20, `+${points}${comboText}`, 0, 255, 136, comboMult > 1 ? 20 : 16);

  // Split chain: boss → 2 large → 2 medium → 2 small (small doesn't split)
  const splitMap = { boss: 'large', large: 'medium', medium: 'small' };
  const splitType = splitMap[m.type];
  if (splitType) {
    for (let s = 0; s < 2; s++) {
      const tX = m.x + (s === 0 ? -1 : 1) * (80 + Math.random() * 100);
      meteors.push(createMeteor(splitType, m.x, tX, m.y, m.material));
    }
  }

  meteors.splice(index, 1);
}

// ─── METEOR HIT DOME ───
function meteorHitDome(m, index) {
  baseHealth--;
  shakeTime = 300;
  shakeIntensity = 12;
  flashAlpha = 0.3;

  const domeCX = getTurretX();
  const domeCY = getGroundY();
  const dmx = m.x - domeCX;
  const dmy = m.y - domeCY;
  const domeDist = Math.sqrt(dmx * dmx + dmy * dmy);
  const domeR = CFG.domeR;
  const impactX = domeCX + (dmx / domeDist) * domeR;
  const impactY = domeCY + (dmy / domeDist) * domeR;

  createExplosion(impactX, impactY, m.r * 2, true);
  createFloatingText(impactX, impactY - 20, 'IMPACTO!', 255, 34, 68, 22);

  const turretLossChance = m.isBoss ? 0.8 : m.type === 'large' ? 0.6 : m.type === 'medium' ? 0.4 : 0.2;
  if (Math.random() < turretLossChance) {
    deactivateRandomTurret();
  }

  for (let i = 0; i < 30; i++) {
    const angle = -Math.PI * Math.random();
    const speed = Math.random() * 5 + 2;
    particles.push({
      x: impactX, y: impactY,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      r: 255, g: Math.floor(Math.random() * 100), b: 0,
      size: Math.random() * 5 + 2,
      age: 0,
      maxAge: Math.random() * 800 + 300,
    });
  }

  meteors.splice(index, 1);

  if (baseHealth <= 0) {
    gameOver();
  }
}

// ─── GAME FLOW ───
function startGame() {
  gameState = 'playing';
  score = 0;
  wave = 1;
  baseHealth = CFG.baseHealth;
  initCannons();
  combo = 0;
  lastComboTime = 0;
  meteors = [];
  lasers = [];
  explosions = [];
  particles = [];
  floatingTexts = [];
  bonusItems = [];
  groundItems = [];
  shakeTime = 0;
  flashAlpha = 0;

  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('gameover-screen').classList.add('hidden');
  document.getElementById('hud').style.opacity = '1';

  document.getElementById('highscore-hud').textContent = highScore;

  startWave();
}

function gameOver() {
  gameState = 'dead';

  if (score > highScore) {
    highScore = score;
    localStorage.setItem('lunarBaseHighScore', highScore);
  }

  document.getElementById('hud').style.opacity = '0';

  setTimeout(() => {
    document.getElementById('final-score').textContent = `Pontuação: ${score}`;
    document.getElementById('final-wave').textContent = `Ondas Sobrevividas: ${wave}`;
    document.getElementById('final-record').textContent = score >= highScore ? '★ NOVO RECORDE! ★' : `Recorde: ${highScore}`;
    document.getElementById('gameover-screen').classList.remove('hidden');
  }, 800);
}

// ─── UPDATE ───
function update(dt, time) {
  if (gameState !== 'playing') return;

  // Turret rotation toward mouse
  const tx = getTurretX();
  const ty = getTurretY();
  const targetAngle = Math.atan2(mouseY - ty, mouseX - tx);
  // Clamp to upper half
  const clampedAngle = Math.max(-Math.PI + 0.1, Math.min(-0.1, targetAngle));
  turretAngle += (clampedAngle - turretAngle) * 0.15;

  // Per-cannon ammo regen (only active cannons)
  for (const c of cannonStates) {
    if (!c.active) continue;
    c.ammo = Math.min(c.maxAmmo, c.ammo + c.regenRate * dt / 1000);
  }

  // Wave announce timer
  if (waveAnnounceTimer > 0) {
    waveAnnounceTimer -= dt;
    if (waveAnnounceTimer <= 0) {
      document.getElementById('wave-announce').classList.add('hidden');
      wavePaused = false;
    }
  }

  // Wave spawning
  if (!wavePaused) {
    waveSpawnTimer += dt;
    if (waveSpawnTimer >= waveSpawnInterval && waveMetorsRemaining > 0) {
      waveSpawnTimer = 0;
      spawnWaveMeteors();
    }

    // Mid-wave bonus spawning
    bonusSpawnTimer += dt;
    if (bonusSpawnTimer >= bonusSpawnInterval) {
      bonusSpawnTimer = 0;
      tryMidWaveBonus();
    }

    // Check if wave is done
    if (waveMetorsRemaining <= 0 && meteors.length === 0) {
      wave++;
      startWave();
    }
  }

  // Update meteors
  for (let i = meteors.length - 1; i >= 0; i--) {
    const m = meteors[i];
    m.x += m.vx;
    m.y += m.vy;
    m.rotation += m.rotSpeed;

    // Check dome collision (hemisphere)
    const domeR = CFG.domeR;
    const domeCX = getTurretX();
    const domeCY = getGroundY();
    const dmx = m.x - domeCX;
    const dmy = m.y - domeCY;
    const domeDist = Math.sqrt(dmx * dmx + dmy * dmy);
    if (dmy < 0 && domeDist <= domeR + m.r * 0.3) {
      meteorHitDome(m, i);
      continue;
    }

    if (m.y + m.r >= getGroundY()) {
      for (let gi = groundItems.length - 1; gi >= 0; gi--) {
        if (Math.abs(m.x - groundItems[gi].x) < 60) {
          destroyGroundItem(groundItems[gi], gi, m.x);
        }
      }

      for (const c of cannonStates) {
        if (c.active && Math.abs(m.x - c.x) < 30) {
          deactivateRandomTurret();
          break;
        }
      }

      createExplosion(m.x, getGroundY(), m.r, true);
      meteors.splice(i, 1);
    }

    // Off screen
    if (m.x < -100 || m.x > canvas.width + 100 || m.y > canvas.height + 100) {
      meteors.splice(i, 1);
    }
  }

  // Update lasers
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    const step = Math.sqrt(l.vx * l.vx + l.vy * l.vy);
    l.x += l.vx;
    l.y += l.vy;
    l.traveled += step;

    // Update bullet particles
    for (const b of l.bullets) {
      if (b.hit || b.offscreen) continue;
      b.x += b.vx;
      b.y += b.vy;
      b.age += dt;
      // Mark as offscreen if exited the viewport
      if (b.x < -20 || b.x > canvas.width + 20 || b.y < -20 || b.y > canvas.height + 20) {
        b.offscreen = true;
      }
    }

    if (checkLaserHit(l)) {
      lasers.splice(i, 1);
    }
  }

  // Update explosions
  for (let i = explosions.length - 1; i >= 0; i--) {
    explosions[i].age += dt;
    if (explosions[i].age >= explosions[i].maxAge) {
      explosions.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05;
    p.age += dt;
    if (p.age >= p.maxAge) particles.splice(i, 1);
  }

  // Update floating texts
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.y += ft.vy;
    ft.age += dt;
    if (ft.age >= ft.maxAge) floatingTexts.splice(i, 1);
  }

  // Update bonus items
  for (let i = bonusItems.length - 1; i >= 0; i--) {
    const bi = bonusItems[i];
    bi.x += bi.vx;
    bi.y += bi.vy;

    // Reached the ground or offscreen — just disappear, no penalty
    if (bi.y + bi.r >= getGroundY() || bi.x < -50 || bi.x > canvas.width + 50 || bi.y > canvas.height + 50) {
      bonusItems.splice(i, 1);
    }
  }

  // Screen shake decay
  if (shakeTime > 0) shakeTime -= dt;

  // Flash decay
  if (flashAlpha > 0) flashAlpha -= dt * 0.001;

  // Combo decay
  if (combo > 0 && performance.now() - lastComboTime > CFG.comboTimeLimit) {
    combo = 0;
  }

  // Update HUD
  document.getElementById('score-hud').textContent = score;
  document.getElementById('wave-hud').textContent = `ONDA ${wave}`;
  document.getElementById('health-bar').style.width = `${(baseHealth / CFG.baseHealth) * 100}%`;
  const activeCannons = cannonStates.filter(c => c.active);
  const totalAmmo = activeCannons.reduce((s, c) => s + c.ammo, 0);
  const totalMax = activeCannons.reduce((s, c) => s + c.maxAmmo, 0);
  document.getElementById('ammo-bar').style.width = `${(totalAmmo / totalMax) * 100}%`;

  const comboEl = document.getElementById('combo-hud');
  if (combo > 1) {
    comboEl.textContent = `COMBO x${combo}`;
    comboEl.classList.add('visible');
  } else {
    comboEl.classList.remove('visible');
  }
}

// ─── RENDER ───
function render(time) {
  ctx.save();

  // Screen shake
  if (shakeTime > 0) {
    const sx = (Math.random() - 0.5) * shakeIntensity;
    const sy = (Math.random() - 0.5) * shakeIntensity;
    ctx.translate(sx, sy);
  }

  // Clear
  ctx.fillStyle = '#0a0a12';
  ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

  // Stars
  drawStars(time);

  // Lunar surface
  drawLunarSurface();

  // Ground items (batteries, solar panels) — behind the base
  drawGroundItems(time);

  // Explosions (behind base)
  for (const e of explosions) drawExplosion(e);

  // Particles
  for (const p of particles) drawParticle(p);

  // Base
  drawBase();

  // Meteors
  for (const m of meteors) drawMeteor(m, time);

  // Bonus items (falling, after meteors)
  for (const bi of bonusItems) drawBonusItem(bi, time);

  // Lasers
  for (const l of lasers) drawLaser(l);

  // Turret (on top)
  drawTurret(time);

  // Floating texts
  for (const ft of floatingTexts) drawFloatingText(ft);

  // Screen flash
  if (flashAlpha > 0) {
    ctx.fillStyle = `rgba(0,255,136,${flashAlpha})`;
    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);
  }

  ctx.restore();

  // Crosshair (not affected by shake)
  if (gameState === 'playing') {
    ctx.strokeStyle = 'rgba(0,255,136,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 12, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(mouseX - 18, mouseY);
    ctx.lineTo(mouseX - 8, mouseY);
    ctx.moveTo(mouseX + 8, mouseY);
    ctx.lineTo(mouseX + 18, mouseY);
    ctx.moveTo(mouseX, mouseY - 18);
    ctx.lineTo(mouseX, mouseY - 8);
    ctx.moveTo(mouseX, mouseY + 8);
    ctx.lineTo(mouseX, mouseY + 18);
    ctx.stroke();

    // Dot center
    ctx.fillStyle = 'rgba(0,255,136,0.8)';
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ─── GAME LOOP ───
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min(timestamp - lastTime, 50);
  lastTime = timestamp;

  update(dt, timestamp);
  render(timestamp);

  requestAnimationFrame(gameLoop);
}

// ─── INPUT ───
let pointerDown = false;

function handlePointerDown(x, y) {
  if (gameState === 'start') {
    startGame();
    return;
  }
  if (gameState === 'playing') {
    pointerDown = true;
    shoot(x, y);
  }
}

function handlePointerUp() {
  pointerDown = false;
}

// Autofire loop - shoots while pointer is held
function autofireCheck() {
  if (pointerDown && gameState === 'playing') {
    shoot(mouseX, mouseY);
  }
  requestAnimationFrame(autofireCheck);
}
requestAnimationFrame(autofireCheck);

// Start screen click — overlay blocks canvas so listen on it directly
document.getElementById('start-screen').addEventListener('click', () => {
  if (gameState === 'start') startGame();
});
document.getElementById('start-screen').addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (gameState === 'start') startGame();
}, { passive: false });

canvas.addEventListener('mousedown', (e) => {
  handlePointerDown(e.clientX, e.clientY);
});

canvas.addEventListener('mouseup', handlePointerUp);
document.addEventListener('mouseup', handlePointerUp);

canvas.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  mouseX = t.clientX;
  mouseY = t.clientY;
  handlePointerDown(t.clientX, t.clientY);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  mouseX = t.clientX;
  mouseY = t.clientY;
}, { passive: false });

canvas.addEventListener('touchend', handlePointerUp);
canvas.addEventListener('touchcancel', handlePointerUp);

document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('touchstart', (e) => {
  e.preventDefault();
  e.stopPropagation();
  startGame();
});

// Prevent scroll
document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

// ─── INIT ───
document.getElementById('highscore-hud').textContent = highScore;
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
